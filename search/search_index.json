{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Dealroadshow K8S Framework is an open-source framework that allows you to define Kubernetes manifests using PHP and full power of Symfony Framework . You then may generate standard YAML manifests and apply them to your Kubernetes cluster. Please see How to read this docs before diving deeper into other articles. Take a look at our vision if you want to decide whether K8S Framework is a good tool for you and to compare it with similar popular tools. Head to Installation page for installation instructions. In order to quickly start writing your manifests, see Getting started . Read about important basic concepts of K8S Framework, such as Manifests , Containers and Apps before jumping to complex topics, such as Manifest methods interception and Environments management .","title":"Overview"},{"location":"#overview","text":"Dealroadshow K8S Framework is an open-source framework that allows you to define Kubernetes manifests using PHP and full power of Symfony Framework . You then may generate standard YAML manifests and apply them to your Kubernetes cluster. Please see How to read this docs before diving deeper into other articles. Take a look at our vision if you want to decide whether K8S Framework is a good tool for you and to compare it with similar popular tools. Head to Installation page for installation instructions. In order to quickly start writing your manifests, see Getting started . Read about important basic concepts of K8S Framework, such as Manifests , Containers and Apps before jumping to complex topics, such as Manifest methods interception and Environments management .","title":"Overview"},{"location":"env-management/","text":"Environments management Today's product development lifecycle has many stages, which can include feature development, autotests, quality assurance (manual testing), demo for product owners on staging environment, and finally, deploy to production. It's considered good practice to keep all your environments similar, so if you are using Kubernetes for production - it's a good idea if your QA environment, staging etc. use Kubernetes too. If that is your case - you probably need slightly different manifests for each environment. For example: you need different credentials to your databases and third-party services; you may allocate many resources (cpu and memory) for your container's in production due to high load, but you don't want to overpay for the same resources in QA environment, and probably you want to give as little resources as possible to your workloads in your dev environment, if it resides on your laptop; some workloads should be running only on some environments. Simplest way to manage environments for your manifests using K8S Framework is to generate different manifests depending on Symfony environment your generation command (like bin/console k8s:dump:all ) was run with. Symfony derives it's environment from APP_ENV environment variable. This variable is also defined in your .env file if you've generated Symfony project by symfony new console command. When Symfony application is started, environment name is stored in kernel.environment DI parameter . Tip If you don't understand concept behind .env file, please read about that in Symfony docs . Generally, if you use Symfony environment as environment for your manifests, you have two main options to generate different manifests for different envs. Using configuration files First option is to use Symfony configuration environments to define different values for different environments. You then may access and use your configuration values in manifest classes. Short info on configuring your manifests is located in Manifests article. Tip If you are writing reusable app and want to distribute it - you probably want to create your own configuration structure for that app. Dedicated article contains all needed information and links to Symfony docs for that matter. The downside of this solution is that your manifest classes are not descriptive - you just return some configuration values, and you cannot tell what are that values just by looking at your class. For example, let's say you have ExampleDeployment class, and you are defining resources for it using configuration values: ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function resources(ContainerResourcesInterface $resources): void { $config = $this->config; $resources ->requestCPU(CPU::millicores($config['cpu']['requests'])) ->requestMemory(Memory::mebibytes($config['memory']['requests'])) ->limitCPU(CPU::millicores($config['cpu']['limits'])) ->limitMemory(Memory::mebibytes($config['memory']['limits'])) ; } //... } What can you say about this deployment's resources consumption without generating YAML from it and looking into it? Probably nothing. In order to know real values, you must look at Symfony configuration file for the corresponding environment. But K8S Framework was designed for you to write self-descriptive manifest classes, so below is our second option . Using env-suffixed methods Second option to manage your envs is to use env-suffixed methods . This option is a recomended way to manage environments for your manifests, unless you are writing reusable app , in which case you need to give your users a way to configure it. Env-suffixed methods technique allows you to create a copy of a method you want to modify for some environment, with a sufix of environment name. It's easier to demonstrate that than explain, so let's rewrite our ExampleDeployment::resources() method from above example to show you how it's done: class ExampleDeployment extends AbstractContainerDeployment { public function resources(ContainerResourcesInterface $resources): void { $resources ->requestCPU(CPU::millicores(200)) ->requestMemory(Memory::mebibytes(400)) ->limitCPU(CPU::millicores(500)) ->limitMemory(Memory::mebibytes(800)) ; } public function resourcesProd(ContainerResourcesInterface $resources): void { $resources ->limitCPU(CPU::cores(2)) ->limitMemory(Memory::gibibytes(2)) ; } public function resourcesDev(ContainerResourcesInterface $resources): void { $resources ->requestCPU(CPU::millicores(50)) ->requestMemory(Memory::mebibytes(100)) ; } //... } Let's discuss what hapens here. Default method resources() will be called always , e.g. for any environment. If environment is prod , method resourcesProd() will be called after method resources() and thus will modify only cpu and memory limits, leaving requests as defined in resources() . If environment is dev , method resourcesDev() will be called after method resources() and will rewrite only cpu and memory requests, leaving limits as defined in resources() . We can check that by dumping manifests first with prod env, and then with dev env. Dumping with prod env: bin/console k8s:dump:all --env = prod If we look at resulting manifest, we'll find that resources section looks like follows: example.deployment.yaml # ... resources : limits : { cpu : '2' , memory : 2Gi } requests : { cpu : 200m , memory : 400Mi } As we see, we have requests from original resources() method and limits from resourcesProd() . And if we dump manifests by calling bin/console k8s:dump:all --env=dev and look at the resources section in example.deployment.yaml , it will look like follows: example.deployment.yaml # ... resources : limits : { cpu : 500m , memory : 800Mi } requests : { cpu : 50m , memory : 100Mi } Again, we see limits from resources() method and requests from resourcesDev() . So, the easiest way to define env-suffuxed method is to copy original method ( resources() method in examples above) and paste it in your class, then add to it's name suffix with a name of the environment, for which you want this method to be called. Then just replace the body of the env-suffixed method with whatever modifications you want to do. Env-suffixed methods availability By default only resources() and replicas() methods support env-suffixed variants. But it's very easy to make any method you want to work like this. Just create event subscriber class that extends special abstract class AbstractEnvAwareMethodSubscriber , defined by K8S bundle. For example, if you want to use env-suffixed variants of method containers() , create such event subscriber: ContainersMethodSubscriber.php class ContainersMethodSubscriber extends AbstractEnvAwareMethodSubscriber { protected function methodName(): string { return 'containers'; } protected function supports(ManifestMethodCalledEvent $event): bool { return $event->manifest() instanceof DeploymentInterface; } } Now you can use env-suffixed variants of containers() method in all your deployment classes: ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function containers(): iterable { yield $this; yield new NginxContainer(); } public function containersProd(): iterable { yield $this; yield new NginxContainer(); yield new MonitoringContainer(); } //... } Using methods interception for env management Sometimes you want to set reasonable defaults for some environment without defining env-suffixed methods in every class. For example, you may want to set default resource requests for all your deployments to some minimal value for dev environment. You may use methods interception technique for that. If you haven't read about methods interception yet, please read that article before you continue to read this section. Let's create event subscriber that will set minimal resources for dev environment for all deployments that don't define them explicitly: DevResourcesSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #[When(env: 'dev')] class DevResourcesSubscriber extends AbstractMethodResultSubscriber { protected function supports(ManifestMethodCalledEvent $event): bool { return $event->manifest() instanceof AbstractContainerDeployment && 'resources' === $event->methodName(); } protected function afterMethod(ManifestMethodCalledEvent $event): void { if (method_exists($event->manifest(), 'resourcesDev')) { // Resources for dev env are handled explicitly return; } /** @var ContainerResourcesInterface $resources */ $resources = $event->methodParams()['resources']; $resources ->requestCPU(CPU::millicores(50)) ->requestMemory(Memory::mebibytes(50)) ; } } Now, every time we generate manifests for dev environment, all deployments will request 50 mebibytes of memory and 50 millicores, unless they defined their resources requests for dev env explicitly by defining method resourcesDev() . Interesting Please notice PHP attribute When in line 1 above - this attribute comes with Symfony, and using it with our subscriber class ensures that this class will be registered in Symfony's Dependency Injection Container only when Symfony environment is dev . Thanks to that, we don't check current environment in subscriber code. Summary Though a choice of environmants management method is a matter of taste, generally you should use env-suffixed methods, since it makes your manifest classes self-descriptive - you can see everything and for all environments just by looking at your class. If you create reusable app , please package it as a Symfony bundle and create friendly configuration for it. Use methods interception technique if you want to change some behavior in all manifests for some environment.","title":"Environments management"},{"location":"env-management/#environments-management","text":"Today's product development lifecycle has many stages, which can include feature development, autotests, quality assurance (manual testing), demo for product owners on staging environment, and finally, deploy to production. It's considered good practice to keep all your environments similar, so if you are using Kubernetes for production - it's a good idea if your QA environment, staging etc. use Kubernetes too. If that is your case - you probably need slightly different manifests for each environment. For example: you need different credentials to your databases and third-party services; you may allocate many resources (cpu and memory) for your container's in production due to high load, but you don't want to overpay for the same resources in QA environment, and probably you want to give as little resources as possible to your workloads in your dev environment, if it resides on your laptop; some workloads should be running only on some environments. Simplest way to manage environments for your manifests using K8S Framework is to generate different manifests depending on Symfony environment your generation command (like bin/console k8s:dump:all ) was run with. Symfony derives it's environment from APP_ENV environment variable. This variable is also defined in your .env file if you've generated Symfony project by symfony new console command. When Symfony application is started, environment name is stored in kernel.environment DI parameter . Tip If you don't understand concept behind .env file, please read about that in Symfony docs . Generally, if you use Symfony environment as environment for your manifests, you have two main options to generate different manifests for different envs.","title":"Environments management"},{"location":"env-management/#using-configuration-files","text":"First option is to use Symfony configuration environments to define different values for different environments. You then may access and use your configuration values in manifest classes. Short info on configuring your manifests is located in Manifests article. Tip If you are writing reusable app and want to distribute it - you probably want to create your own configuration structure for that app. Dedicated article contains all needed information and links to Symfony docs for that matter. The downside of this solution is that your manifest classes are not descriptive - you just return some configuration values, and you cannot tell what are that values just by looking at your class. For example, let's say you have ExampleDeployment class, and you are defining resources for it using configuration values: ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function resources(ContainerResourcesInterface $resources): void { $config = $this->config; $resources ->requestCPU(CPU::millicores($config['cpu']['requests'])) ->requestMemory(Memory::mebibytes($config['memory']['requests'])) ->limitCPU(CPU::millicores($config['cpu']['limits'])) ->limitMemory(Memory::mebibytes($config['memory']['limits'])) ; } //... } What can you say about this deployment's resources consumption without generating YAML from it and looking into it? Probably nothing. In order to know real values, you must look at Symfony configuration file for the corresponding environment. But K8S Framework was designed for you to write self-descriptive manifest classes, so below is our second option .","title":"Using configuration files"},{"location":"env-management/#using-env-suffixed-methods","text":"Second option to manage your envs is to use env-suffixed methods . This option is a recomended way to manage environments for your manifests, unless you are writing reusable app , in which case you need to give your users a way to configure it. Env-suffixed methods technique allows you to create a copy of a method you want to modify for some environment, with a sufix of environment name. It's easier to demonstrate that than explain, so let's rewrite our ExampleDeployment::resources() method from above example to show you how it's done: class ExampleDeployment extends AbstractContainerDeployment { public function resources(ContainerResourcesInterface $resources): void { $resources ->requestCPU(CPU::millicores(200)) ->requestMemory(Memory::mebibytes(400)) ->limitCPU(CPU::millicores(500)) ->limitMemory(Memory::mebibytes(800)) ; } public function resourcesProd(ContainerResourcesInterface $resources): void { $resources ->limitCPU(CPU::cores(2)) ->limitMemory(Memory::gibibytes(2)) ; } public function resourcesDev(ContainerResourcesInterface $resources): void { $resources ->requestCPU(CPU::millicores(50)) ->requestMemory(Memory::mebibytes(100)) ; } //... } Let's discuss what hapens here. Default method resources() will be called always , e.g. for any environment. If environment is prod , method resourcesProd() will be called after method resources() and thus will modify only cpu and memory limits, leaving requests as defined in resources() . If environment is dev , method resourcesDev() will be called after method resources() and will rewrite only cpu and memory requests, leaving limits as defined in resources() . We can check that by dumping manifests first with prod env, and then with dev env. Dumping with prod env: bin/console k8s:dump:all --env = prod If we look at resulting manifest, we'll find that resources section looks like follows: example.deployment.yaml # ... resources : limits : { cpu : '2' , memory : 2Gi } requests : { cpu : 200m , memory : 400Mi } As we see, we have requests from original resources() method and limits from resourcesProd() . And if we dump manifests by calling bin/console k8s:dump:all --env=dev and look at the resources section in example.deployment.yaml , it will look like follows: example.deployment.yaml # ... resources : limits : { cpu : 500m , memory : 800Mi } requests : { cpu : 50m , memory : 100Mi } Again, we see limits from resources() method and requests from resourcesDev() . So, the easiest way to define env-suffuxed method is to copy original method ( resources() method in examples above) and paste it in your class, then add to it's name suffix with a name of the environment, for which you want this method to be called. Then just replace the body of the env-suffixed method with whatever modifications you want to do.","title":"Using env-suffixed methods"},{"location":"env-management/#env-suffixed-methods-availability","text":"By default only resources() and replicas() methods support env-suffixed variants. But it's very easy to make any method you want to work like this. Just create event subscriber class that extends special abstract class AbstractEnvAwareMethodSubscriber , defined by K8S bundle. For example, if you want to use env-suffixed variants of method containers() , create such event subscriber: ContainersMethodSubscriber.php class ContainersMethodSubscriber extends AbstractEnvAwareMethodSubscriber { protected function methodName(): string { return 'containers'; } protected function supports(ManifestMethodCalledEvent $event): bool { return $event->manifest() instanceof DeploymentInterface; } } Now you can use env-suffixed variants of containers() method in all your deployment classes: ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function containers(): iterable { yield $this; yield new NginxContainer(); } public function containersProd(): iterable { yield $this; yield new NginxContainer(); yield new MonitoringContainer(); } //... }","title":"Env-suffixed methods availability"},{"location":"env-management/#using-methods-interception-for-env-management","text":"Sometimes you want to set reasonable defaults for some environment without defining env-suffixed methods in every class. For example, you may want to set default resource requests for all your deployments to some minimal value for dev environment. You may use methods interception technique for that. If you haven't read about methods interception yet, please read that article before you continue to read this section. Let's create event subscriber that will set minimal resources for dev environment for all deployments that don't define them explicitly: DevResourcesSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #[When(env: 'dev')] class DevResourcesSubscriber extends AbstractMethodResultSubscriber { protected function supports(ManifestMethodCalledEvent $event): bool { return $event->manifest() instanceof AbstractContainerDeployment && 'resources' === $event->methodName(); } protected function afterMethod(ManifestMethodCalledEvent $event): void { if (method_exists($event->manifest(), 'resourcesDev')) { // Resources for dev env are handled explicitly return; } /** @var ContainerResourcesInterface $resources */ $resources = $event->methodParams()['resources']; $resources ->requestCPU(CPU::millicores(50)) ->requestMemory(Memory::mebibytes(50)) ; } } Now, every time we generate manifests for dev environment, all deployments will request 50 mebibytes of memory and 50 millicores, unless they defined their resources requests for dev env explicitly by defining method resourcesDev() . Interesting Please notice PHP attribute When in line 1 above - this attribute comes with Symfony, and using it with our subscriber class ensures that this class will be registered in Symfony's Dependency Injection Container only when Symfony environment is dev . Thanks to that, we don't check current environment in subscriber code.","title":"Using methods interception for env management"},{"location":"env-management/#summary","text":"Though a choice of environmants management method is a matter of taste, generally you should use env-suffixed methods, since it makes your manifest classes self-descriptive - you can see everything and for all environments just by looking at your class. If you create reusable app , please package it as a Symfony bundle and create friendly configuration for it. Use methods interception technique if you want to change some behavior in all manifests for some environment.","title":"Summary"},{"location":"getting-started/","text":"Getting started Prerequisites This tutorial assumes you have already installed K8S Bundle. The entire Dealroadshow K8S Framework docummentation also assumes that you are already familiar with basic Kubernetes concepts and have at least some experience with the Kubernetes itself. If not - please learn Kubernetes before using this framework. Create an App App is a basic concept in K8S Framework, similar to chart in Helm or, well, app in cdk8s . Put simply - app is a collection of manifests . Basically you will create app to define manifests for one of your services in SOA architecture - in order to distinguish this manifests from other service's manifests. If you have a \"good old\" monolith, your manifests may be split into apps using some other criteria, such as domain contexts in DDD ideology. To create an app - simply open terminal and generate app class using Symfony command, shipped with K8S Bundle: bin/console k8s:generate:app hello If you did not modify K8S Bundle configuration, this command will generate new directory K8S/Hello in your sources dir (by default src in Symfony projects), app class HelloApp and basic dirs that you might want to have in an app: Tip To understand app's directory structure better, please read dedicated article for apps. If you open HelloApp.php file in IDE of your choice - you will see pretty basic class: HelloApp.php class HelloApp extends AbstractApp { public static function name(): string { return 'hello'; } public function manifestConfig(string $shortName): array { return []; } } Method HappyApp::name() is self-explanatory, and other methods are explained in dedicated article . Define your first Deployment Now that we have HelloApp , let's define our first Deployment . Defining deployment using K8S Framework is as simple as defining it's corresponding PHP class for it. We could create deployment class by ourselves, but it would be simpler to generate it using console command: bin/console k8s:generate:manifest world world in command above is simply a short name for manifest. Command will ask you about type of your new manifest and an app , where to generate your new manifest: Let's look at our new deployment class in src/K8S/Hello/Manifest/WorldDeployment.php : WorldDeployment.php class WorldDeployment extends AbstractContainerDeployment { public function image(): Image { return Image::fromName('my-cool/image'); } public function selector(SelectorConfigurator $selector): void { $selector ->addLabel('app', $this->app->alias()) ->addLabel('name', static::shortName()) ; } public static function shortName(): string { return 'world'; } } This class is pretty basic too, but it's already a valid Kubernetes deployment! Dump manifests Let's dump your first manifest to standard Kubernetes YAML and look at it: bin/console k8s:dump:all After running this command we can see our new deployment dumped to file src/Resources/k8s-manifests/hello/world.deployment.yaml : Let's look at this file: hello/world.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion : apps/v1 kind : Deployment metadata : labels : app : hello name : world name : hello-world spec : replicas : 1 selector : matchLabels : app : hello name : world template : metadata : annotations : dealroadshow.com/env-sources-checksum : d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum : d41d8cd98f00b204e9800998ecf8427e labels : app : hello name : world spec : containers : - image : my-cool/image imagePullPolicy : IfNotPresent name : app Few things to note here. First , look how deployment name is formed in line 7 : as you may already guessed, name hello-world is a concatenation of app name, returned from HelloApp::name() method, and manifest short name , returned from WorldDeployment::shortName() . Good news is you will not have to work with full manifest names in your code, but more on that later. Second , look at lines 17-18 . This annotations guarantee that your pods will be recreated whenever any ConfigMaps or Secrets, used in your deployment, changed. You are welcome! Modifying deployment For now we have defined our first deployment. It uses a dummy image name my-cool/image . Let's replace it for a real image name. For demonstration purposes let it be nginx : WorldDeployment.php // ... public function image(): Image { return Image::fromName('nginx'); } Nginx is an open source web-server, so now that we use it, we know that we should expose some ports to the outside world. In Kubernetes manifests it is done by ports section. Dealroadshow K8S Framework follows simple rule: all method names in manifest classes are the same as names in corresponding sections in Kubernetes manifest. It means we should just try to define a method ports() in our deployment. In order to better understand all conventions and best practices for K8S framework, please read Understanding manifests If you are using a good IDE, for example PhpStorm, just write down first letters por and IDE will create this method for you: WorldDeployment.php //... public function ports(PortsConfigurator $ports): void { } Signature of argument $ports is pretty straightforward and simply following your IDE hints you could lead you to the something like this: WorldDeployment.php //... public function ports(PortsConfigurator $ports): void { $ports ->add(80) ->setName('http'); $ports ->add(443) ->setName('https'); } Define a service Now we need to define a Kubernetes service in order to expose our deployment. As you may have already guessed - we will generate PHP class for service: bin/console k8s:generate:manifest world After chosing service as a kind of manifest you will get pretty basic service class WorldService .You can intuitively (and with help of IDE) define service ports in ports() method, but we should also add a selector() method in order for service to point properly to our pods. After this simple modifications our service class should look like follows: WorldService.php class WorldService extends AbstractService { public function ports(ServicePortsConfigurator $ports): void { $ports ->add(80, 80) ->setName('http'); $ports ->add(443, 443) ->setName('https'); } public function selector(StringMap $selector): void { $selector ->add('app', $this->app->alias()) ->add('name', static::shortName()) ; } public static function shortName(): string { return WorldDeployment::shortName(); } } Good to know Please note how we defined short name for a service by reusing short name of deployment.It is a good practice to use deployment name in service, and service name in ingress - in further articles we will learn techniques of how to automatically define selectors and ports for our services based on it's names. If you dump your manifests now by console command k8s:dump:all , you'll get your deployment and a service pointing to deployment's pods. In other articles we dive deeper into defining manifests and internals of K8S Framework.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#prerequisites","text":"This tutorial assumes you have already installed K8S Bundle. The entire Dealroadshow K8S Framework docummentation also assumes that you are already familiar with basic Kubernetes concepts and have at least some experience with the Kubernetes itself. If not - please learn Kubernetes before using this framework.","title":"Prerequisites"},{"location":"getting-started/#create-an-app","text":"App is a basic concept in K8S Framework, similar to chart in Helm or, well, app in cdk8s . Put simply - app is a collection of manifests . Basically you will create app to define manifests for one of your services in SOA architecture - in order to distinguish this manifests from other service's manifests. If you have a \"good old\" monolith, your manifests may be split into apps using some other criteria, such as domain contexts in DDD ideology. To create an app - simply open terminal and generate app class using Symfony command, shipped with K8S Bundle: bin/console k8s:generate:app hello If you did not modify K8S Bundle configuration, this command will generate new directory K8S/Hello in your sources dir (by default src in Symfony projects), app class HelloApp and basic dirs that you might want to have in an app: Tip To understand app's directory structure better, please read dedicated article for apps. If you open HelloApp.php file in IDE of your choice - you will see pretty basic class: HelloApp.php class HelloApp extends AbstractApp { public static function name(): string { return 'hello'; } public function manifestConfig(string $shortName): array { return []; } } Method HappyApp::name() is self-explanatory, and other methods are explained in dedicated article .","title":"Create an App"},{"location":"getting-started/#define-your-first-deployment","text":"Now that we have HelloApp , let's define our first Deployment . Defining deployment using K8S Framework is as simple as defining it's corresponding PHP class for it. We could create deployment class by ourselves, but it would be simpler to generate it using console command: bin/console k8s:generate:manifest world world in command above is simply a short name for manifest. Command will ask you about type of your new manifest and an app , where to generate your new manifest: Let's look at our new deployment class in src/K8S/Hello/Manifest/WorldDeployment.php : WorldDeployment.php class WorldDeployment extends AbstractContainerDeployment { public function image(): Image { return Image::fromName('my-cool/image'); } public function selector(SelectorConfigurator $selector): void { $selector ->addLabel('app', $this->app->alias()) ->addLabel('name', static::shortName()) ; } public static function shortName(): string { return 'world'; } } This class is pretty basic too, but it's already a valid Kubernetes deployment!","title":"Define your first Deployment"},{"location":"getting-started/#dump-manifests","text":"Let's dump your first manifest to standard Kubernetes YAML and look at it: bin/console k8s:dump:all After running this command we can see our new deployment dumped to file src/Resources/k8s-manifests/hello/world.deployment.yaml : Let's look at this file: hello/world.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion : apps/v1 kind : Deployment metadata : labels : app : hello name : world name : hello-world spec : replicas : 1 selector : matchLabels : app : hello name : world template : metadata : annotations : dealroadshow.com/env-sources-checksum : d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum : d41d8cd98f00b204e9800998ecf8427e labels : app : hello name : world spec : containers : - image : my-cool/image imagePullPolicy : IfNotPresent name : app Few things to note here. First , look how deployment name is formed in line 7 : as you may already guessed, name hello-world is a concatenation of app name, returned from HelloApp::name() method, and manifest short name , returned from WorldDeployment::shortName() . Good news is you will not have to work with full manifest names in your code, but more on that later. Second , look at lines 17-18 . This annotations guarantee that your pods will be recreated whenever any ConfigMaps or Secrets, used in your deployment, changed. You are welcome!","title":"Dump manifests"},{"location":"getting-started/#modifying-deployment","text":"For now we have defined our first deployment. It uses a dummy image name my-cool/image . Let's replace it for a real image name. For demonstration purposes let it be nginx : WorldDeployment.php // ... public function image(): Image { return Image::fromName('nginx'); } Nginx is an open source web-server, so now that we use it, we know that we should expose some ports to the outside world. In Kubernetes manifests it is done by ports section. Dealroadshow K8S Framework follows simple rule: all method names in manifest classes are the same as names in corresponding sections in Kubernetes manifest. It means we should just try to define a method ports() in our deployment. In order to better understand all conventions and best practices for K8S framework, please read Understanding manifests If you are using a good IDE, for example PhpStorm, just write down first letters por and IDE will create this method for you: WorldDeployment.php //... public function ports(PortsConfigurator $ports): void { } Signature of argument $ports is pretty straightforward and simply following your IDE hints you could lead you to the something like this: WorldDeployment.php //... public function ports(PortsConfigurator $ports): void { $ports ->add(80) ->setName('http'); $ports ->add(443) ->setName('https'); }","title":"Modifying deployment"},{"location":"getting-started/#define-a-service","text":"Now we need to define a Kubernetes service in order to expose our deployment. As you may have already guessed - we will generate PHP class for service: bin/console k8s:generate:manifest world After chosing service as a kind of manifest you will get pretty basic service class WorldService .You can intuitively (and with help of IDE) define service ports in ports() method, but we should also add a selector() method in order for service to point properly to our pods. After this simple modifications our service class should look like follows: WorldService.php class WorldService extends AbstractService { public function ports(ServicePortsConfigurator $ports): void { $ports ->add(80, 80) ->setName('http'); $ports ->add(443, 443) ->setName('https'); } public function selector(StringMap $selector): void { $selector ->add('app', $this->app->alias()) ->add('name', static::shortName()) ; } public static function shortName(): string { return WorldDeployment::shortName(); } } Good to know Please note how we defined short name for a service by reusing short name of deployment.It is a good practice to use deployment name in service, and service name in ingress - in further articles we will learn techniques of how to automatically define selectors and ports for our services based on it's names. If you dump your manifests now by console command k8s:dump:all , you'll get your deployment and a service pointing to deployment's pods. In other articles we dive deeper into defining manifests and internals of K8S Framework.","title":"Define a service"},{"location":"how-to-read/","text":"How to read this docs This docummentations uses some conventions to make articles shorter and avoid repetitiveness. Here are some of them: K8S framework Everywhere you see usage of \" K8S Framework \" term - it refers to the combination of Dealroadshow K8S Framework and Dealroadshow K8S Bundle used with Symfony project. Apps and application When you see word \" app \" in this docs - it's about one of the basic K8S Framework concepts. Whenever you see word \" application \" it means your Symfony application, that uses K8S Framework and generates Kubernetes manifests .","title":"How to read this docs"},{"location":"how-to-read/#how-to-read-this-docs","text":"This docummentations uses some conventions to make articles shorter and avoid repetitiveness. Here are some of them:","title":"How to read this docs"},{"location":"how-to-read/#k8s-framework","text":"Everywhere you see usage of \" K8S Framework \" term - it refers to the combination of Dealroadshow K8S Framework and Dealroadshow K8S Bundle used with Symfony project.","title":"K8S framework"},{"location":"how-to-read/#apps-and-application","text":"When you see word \" app \" in this docs - it's about one of the basic K8S Framework concepts. Whenever you see word \" application \" it means your Symfony application, that uses K8S Framework and generates Kubernetes manifests .","title":"Apps and application"},{"location":"installation/","text":"Installation Prerequisites Dealroadshow K8S Framework requires PHP version 8.1 or higher. Although Dealroadshow K8S Framework is released as a standalone package and can be used with a PHP framework of your preference or without any of them, it is highly recommended to use it with Symfony Framework by installing Dealroadshow K8S Bundle , since it allows you to write your Kubernetes manifests using Dependency Injection and all the cool Symfony features, such as autowiring and autoconfiguration . In fact, integration with Symfony is one of killer-features of this project and one of the reasons it was created. Further documentation assumes you use Dealroadshow K8S Framework as a Symfony bundle . Install Kubernetes API classes First, you should look, what Kubernetes version your cluster has. This is needed so that K8S Framework can generate Kubernetes manifests in format, compatible with your Kubernetes cluster. Suppose you're using Kubernetes v1.22 . You should install Kubernetes API classes for PHP by installing dealroadshow/k8s-resources package: composer require dealroadshow/k8s-resources \"~1.22.0\" Versions of dealroadshow/k8s-resources package follow Kubernetes versions in terms of it's minor versions , so just use the version of your cluster for this package. Attention Do not use caret operator ^ in version number for dealroadshow/k8s-resources package, because Composer will install latest minor version of this package. Suppose you're using Kubernetes v1.21 and you're trying to install corresponding version of API classes using version constraint ^1.21 . This will end up by latest API classes version being installed (for example, v1.23 ). This is totally not what you want, so use tilde operator ~ instead and specify patch part of version ( ~1.22.0 , not ~1.22 ). Will I always have needed version of this package? Don't worry that some day there will be no classes for your Kubernetes version or they will not match needed format - this PHP classes are autogenerated from Kubernetes API specs using a tool that was created specifically for that - Dealroadshow Kodegen . This ensures you'll always have your API classes up to date and compatible with your cluster. Install K8S bundle for Symfony It's your choice whether to create a separate Symfony project for your Kubernetes manifests generation or to install this bundle into you existing Symfony project (if you do have one). But separate project would probably ease managing and updates to Symfony Framework itself and any other packages. After you installed Kubernetes API classes by installing dealroadshow/k8s-resources , just install the latest version of Dealroadshow K8S Bundle via Composer: composer require dealroadshow/k8s-bundle That's pretty it! Now you can dive into writing your own manifests.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequisites","text":"Dealroadshow K8S Framework requires PHP version 8.1 or higher. Although Dealroadshow K8S Framework is released as a standalone package and can be used with a PHP framework of your preference or without any of them, it is highly recommended to use it with Symfony Framework by installing Dealroadshow K8S Bundle , since it allows you to write your Kubernetes manifests using Dependency Injection and all the cool Symfony features, such as autowiring and autoconfiguration . In fact, integration with Symfony is one of killer-features of this project and one of the reasons it was created. Further documentation assumes you use Dealroadshow K8S Framework as a Symfony bundle .","title":"Prerequisites"},{"location":"installation/#install-kubernetes-api-classes","text":"First, you should look, what Kubernetes version your cluster has. This is needed so that K8S Framework can generate Kubernetes manifests in format, compatible with your Kubernetes cluster. Suppose you're using Kubernetes v1.22 . You should install Kubernetes API classes for PHP by installing dealroadshow/k8s-resources package: composer require dealroadshow/k8s-resources \"~1.22.0\" Versions of dealroadshow/k8s-resources package follow Kubernetes versions in terms of it's minor versions , so just use the version of your cluster for this package. Attention Do not use caret operator ^ in version number for dealroadshow/k8s-resources package, because Composer will install latest minor version of this package. Suppose you're using Kubernetes v1.21 and you're trying to install corresponding version of API classes using version constraint ^1.21 . This will end up by latest API classes version being installed (for example, v1.23 ). This is totally not what you want, so use tilde operator ~ instead and specify patch part of version ( ~1.22.0 , not ~1.22 ). Will I always have needed version of this package? Don't worry that some day there will be no classes for your Kubernetes version or they will not match needed format - this PHP classes are autogenerated from Kubernetes API specs using a tool that was created specifically for that - Dealroadshow Kodegen . This ensures you'll always have your API classes up to date and compatible with your cluster.","title":"Install Kubernetes API classes"},{"location":"installation/#install-k8s-bundle-for-symfony","text":"It's your choice whether to create a separate Symfony project for your Kubernetes manifests generation or to install this bundle into you existing Symfony project (if you do have one). But separate project would probably ease managing and updates to Symfony Framework itself and any other packages. After you installed Kubernetes API classes by installing dealroadshow/k8s-resources , just install the latest version of Dealroadshow K8S Bundle via Composer: composer require dealroadshow/k8s-bundle That's pretty it! Now you can dive into writing your own manifests.","title":"Install K8S bundle for Symfony"},{"location":"lifecycle/","text":"K8S Framework application lifecycle Prerequisites This article assumes that you are: familiar with Kubernetes itself have read about manifests have basic understanding of apps concept Console commands K8S Bundle defines 4 console commands for manifest generation, which can be used with Symfony Console entry-point bin/console : k8s:dump:all - dump all manifests as YAML files to configured location (by default - src/App/Resources/k8s-manifests dir) k8s:dump:apps - dump manifests from chosen apps k8s:print:all - print all manifests to stdout in YAML format k8s:print:apps - print manifests from chosen apps to stdout in YAML format Despite small differences in this commands, app's lifecycle is the same for any of them. Application lifecycle \" Application \" here refers to the Symfony application that generates manifests when you call one of the console commands listed above, not App in K8S Framework. So what happens when applicaton starts? Collecting app instances Class AppRegistry has a simple API that allows to register / store app instances and retrieve them. Note Thanks to awesome Dependency Injection in Symfony (including autowiring and autoconfiguration ) you just need to define an App class, and it's instance will be created and registered in Symfony's Dependency Injection container. When Symfony application starts, K8S framework retrieves all app instances from Symfony DI-container and registers them in AppRegistry . Good to know This job is done by AppsPass class in K8S Bundle. AppsPass is an example of an important concept in Symfony - Compiler Pass . If you want to dive deeply into how K8S Framework works - you may want to know this concept. After all apps are collected to AppRegistry - it's time to collect manifests and register them in ManifestRegistry . Collecting manifest instances Just like AppRegistry stores app instances, ManifestRegistry class stores and allows to retrieve instances of manifests. Manifests are stored with the information about app they belong to . How does K8S Framework decides, which app owns manifest? By default this is done by checking if manifest class resides in app namespace . Every app is generated in dedicated directory. For example, if we have app class K8S\\Hello\\HelloApp - app namespace is K8S\\Hello\\ and any namespace below. So if we have manifest class K8S\\Hello\\Manifest\\WorldDeployment - K8S framework sees that this deployment's namespase is under HelloApp 's namespace K8S\\Hello\\ and thus registers WorldDeloyment instance in ManifestRegistry as manifest that belongs to HelloApp . Good to know Just like AppsPass registers apps in AppRegistry , the job of collecting manifest instances and adding them to ManifestRegistry is done by another compiler pass - ManifestsPass . Processing apps Now that all apps and manifests are registered in corresponding registries, K8S framework can start to process apps. It iterates over chosen app names, retrieves app instances from AppRegistry and for each app retrieves all instances of manifests that belong to this app. It then iterates over manifests and processes them - native Kubernetes API objects are created and filled with data by calling methods from your manifest instances. The result of processing each manifest is an API object or that implements APIResourceInterface and can be directly encoded into a valid JSON, understandable by your Kubernetes cluster. This API resource object is added to the app instance by calling it's method addManifestFile() (this method is a part of AppInterface ). App is processed when it's manifest are processed and corresponding API objects are added to app. Note You may have noticed that we are calling result of manifest processing \"API object\" or \"API resource\", but method in AppInterface is called addManifestFile() . \"Manifest file\" is a combination of API object and filename it will be dumped with. Dumping manifests When all apps are processed - framework iterates once again over all app instances. This time for each app it retrieves all API resources, added during previous stage, encodes them to YAML format and saves them to filesystem or prints them to stdout, depending on what console command is called. After all manifests are dumped - application made it's job, so it finishes. Summary In this article we learned about lifecycle of manifests generation. If you got to this page by clicking link in Apps article - feel free to return to it.","title":"Application lifecycle"},{"location":"lifecycle/#k8s-framework-application-lifecycle","text":"","title":"K8S Framework application lifecycle"},{"location":"lifecycle/#prerequisites","text":"This article assumes that you are: familiar with Kubernetes itself have read about manifests have basic understanding of apps concept","title":"Prerequisites"},{"location":"lifecycle/#console-commands","text":"K8S Bundle defines 4 console commands for manifest generation, which can be used with Symfony Console entry-point bin/console : k8s:dump:all - dump all manifests as YAML files to configured location (by default - src/App/Resources/k8s-manifests dir) k8s:dump:apps - dump manifests from chosen apps k8s:print:all - print all manifests to stdout in YAML format k8s:print:apps - print manifests from chosen apps to stdout in YAML format Despite small differences in this commands, app's lifecycle is the same for any of them.","title":"Console commands"},{"location":"lifecycle/#application-lifecycle","text":"\" Application \" here refers to the Symfony application that generates manifests when you call one of the console commands listed above, not App in K8S Framework. So what happens when applicaton starts?","title":"Application lifecycle"},{"location":"lifecycle/#collecting-app-instances","text":"Class AppRegistry has a simple API that allows to register / store app instances and retrieve them. Note Thanks to awesome Dependency Injection in Symfony (including autowiring and autoconfiguration ) you just need to define an App class, and it's instance will be created and registered in Symfony's Dependency Injection container. When Symfony application starts, K8S framework retrieves all app instances from Symfony DI-container and registers them in AppRegistry . Good to know This job is done by AppsPass class in K8S Bundle. AppsPass is an example of an important concept in Symfony - Compiler Pass . If you want to dive deeply into how K8S Framework works - you may want to know this concept. After all apps are collected to AppRegistry - it's time to collect manifests and register them in ManifestRegistry .","title":"Collecting app instances"},{"location":"lifecycle/#collecting-manifest-instances","text":"Just like AppRegistry stores app instances, ManifestRegistry class stores and allows to retrieve instances of manifests. Manifests are stored with the information about app they belong to . How does K8S Framework decides, which app owns manifest? By default this is done by checking if manifest class resides in app namespace . Every app is generated in dedicated directory. For example, if we have app class K8S\\Hello\\HelloApp - app namespace is K8S\\Hello\\ and any namespace below. So if we have manifest class K8S\\Hello\\Manifest\\WorldDeployment - K8S framework sees that this deployment's namespase is under HelloApp 's namespace K8S\\Hello\\ and thus registers WorldDeloyment instance in ManifestRegistry as manifest that belongs to HelloApp . Good to know Just like AppsPass registers apps in AppRegistry , the job of collecting manifest instances and adding them to ManifestRegistry is done by another compiler pass - ManifestsPass .","title":"Collecting manifest instances"},{"location":"lifecycle/#processing-apps","text":"Now that all apps and manifests are registered in corresponding registries, K8S framework can start to process apps. It iterates over chosen app names, retrieves app instances from AppRegistry and for each app retrieves all instances of manifests that belong to this app. It then iterates over manifests and processes them - native Kubernetes API objects are created and filled with data by calling methods from your manifest instances. The result of processing each manifest is an API object or that implements APIResourceInterface and can be directly encoded into a valid JSON, understandable by your Kubernetes cluster. This API resource object is added to the app instance by calling it's method addManifestFile() (this method is a part of AppInterface ). App is processed when it's manifest are processed and corresponding API objects are added to app. Note You may have noticed that we are calling result of manifest processing \"API object\" or \"API resource\", but method in AppInterface is called addManifestFile() . \"Manifest file\" is a combination of API object and filename it will be dumped with.","title":"Processing apps"},{"location":"lifecycle/#dumping-manifests","text":"When all apps are processed - framework iterates once again over all app instances. This time for each app it retrieves all API resources, added during previous stage, encodes them to YAML format and saves them to filesystem or prints them to stdout, depending on what console command is called. After all manifests are dumped - application made it's job, so it finishes.","title":"Dumping manifests"},{"location":"lifecycle/#summary","text":"In this article we learned about lifecycle of manifests generation. If you got to this page by clicking link in Apps article - feel free to return to it.","title":"Summary"},{"location":"methods-interception/","text":"Manifest methods interception Sometimes defining Kubernetes manifests involves code repetition, and you have to do the same repetitive job again and again. For example - you almost always have to define metadata labels at the top level of deployment manifest ( metadata.labels ), in pod spec template ( spec.template.metadata.labels ), and then section spec.selector.matchLabels should contain same labels. Thus you need copy-paste same labels 3 times every time you write a manifest. It would be great if there was a way to automate such repetitive tasks, and manifests methods interception is a way to do that in K8S Framework. Dealroadshow K8S Framework uses Proxy pattern to wrap every instance of your manifest classes into a proxy-object. Then, when manifests are processed , all methods of your manifests classes are called on proxy objects. This proxy objects wrap every method of original manifest instance in order to dispatch events before and after calling original methods, thus allowing you to intercept any method call. K8S Framework uses PSR-14 EventDispatcherInterface in order to dispatch all events, and K8S Bundle uses Symfony Event Dispatcher component that implements this interface. Before every manifest method call ManifestMethodEvent is dispatched. After manifest method was called, ManifestMethodCalledEvent is dispatched. Among other things, you then may replace method's return value in event subscriber . Let's demonstrate possibilities of methods interceptions by automating the definition of selector.matchLabels and metadata.labels sections in all manifests, so that you don't have to write those ever again. For that, we will define event subscriber class SelectorLabelsSubscriber in a standard Symfony project location src/EventListener : src/EventListener/SelectorLabelSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class SelectorLabelsSubscriber implements EventSubscriberInterface { public function onManifestMethod(ManifestMethodEvent $event): void { $methodName = $event->methodName(); $params = $event->methodParams(); $manifest = $event->manifest(); if ('selector' !== $methodName || !($manifest instanceof DeploymentInterface)) { // It's either not `selector()` method call, or not deployment's method being called return; } /** @var SelectorConfigurator $selector */ $selector = $params['selector']; /** @var AppInterface $app */ $app = PropertyAccessUtil::getPropertyValue($manifest, 'app'); $selector ->addLabel('app', $app->alias()) ->addLabel('component', $manifest::shortName()) ; } public static function getSubscribedEvents(): array { return [ ManifestMethodEvent::NAME => 'onManifestMethod' ]; } } As we see, our class implements Symfony's native EventSubscriberInterface , so thanks to autoconfiguration, just defining this class and implementing method getSubscribedEvents() as above is enough for it to recieve event every time manifest's method is about to be called. All logic of interception resides in method onManifestMethod() , which recieves events, so let's analyze it: lines 8-10 : we are checking if method being called is called selector , and if that manifest, on which this method is about to be called, is an instance of DeploymentInterface . If one of this conditions is false, we do nothing. Thus we are limiting our event subscriber to calls of method selector() on deployments. line 14 : event object contains all parameters, passed to method being called. Method DeploymentInterface::selector() must recieve SelectorConfigurator instance as $selector argument, so we getting it from array of method params. line 17 : there is no method that returns app in ManifestInterface , but any manifest that inherits K8S Framework's corresponding abstract classes (like AbstractDeployment for deployments) inherits property $app that contains app instance. Since this property is protected , we use Dealroadshow\\Bundle\\K8SBundle\\Util\\PropertyAccessUtil class to retrieve it from manifest instance. lines 19-22 : we are using $selector argument of DeploymentInterface::selector() method to define two labels: app , that contains our app alias , and component , which contains short name of the deployment. Thus any generated deployment will have selector labels automatically. K8S Framework copies all labels from selector.matchLabels to metadata.labels and spec.template.metadata.labels sections automatically - so you'll never have to write this labels again in your deployments - all thanks to one event subscriber. K8S Bundle also has predefined abstract classes that you may inherit from if you want to intercept manifest's methods: AbstractMethodSubscriber and AbstractMethodResultSubscriber - for intercepting method before it was called, or after, respectively. Below is a new version of our SelectorLabelsSubscriber that inherits AbstractMethodSubscriber : src/EventListener/SelectorLabelSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class SelectorLabelsSubscriber extends AbstractMethodSubscriber { protected function supports(ManifestMethodEvent $event): bool { return 'selector' === $event->methodName() && $event->manifest() instanceof DeploymentInterface; } protected function beforeMethod(ManifestMethodEvent $event): void { /** @var SelectorConfigurator $selector */ $selector = $event->methodParams()['selector']; $manifest = $event->manifest(); /** @var AppInterface $app */ $app = PropertyAccessUtil::getPropertyValue($manifest, 'app'); $selector ->addLabel('app', $app->alias()) ->addLabel('component', $manifest::shortName()) ; } } This class is pretty self-explanatory now: method supports() is used to determine whether this subscriber should be called for the given event. Method beforeMethod() (for method result subscribers - afterMethod() ) then does the real job, if supports() returned true. Now that we have our subscriber, let's test it. First, let's define a simplest possible deployment class ExampleDeployment in ExampleApp : src/Example/Manifest/ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function image(): Image { return Image::fromName('my-cool/image'); } public static function shortName(): string { return 'example'; } } Now we can call console command to dump manifests into YAML files: bin/console k8s:dump:all After command finished, let's look what YAML was generated from our ExampleDeployment class: example/example.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion : apps/v1 kind : Deployment metadata : labels : app : example component : example name : example-example spec : replicas : 1 selector : matchLabels : app : example component : example template : metadata : annotations : dealroadshow.com/env-sources-checksum : d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum : d41d8cd98f00b204e9800998ecf8427e labels : app : example component : example spec : containers : - image : my-cool/image imagePullPolicy : IfNotPresent name : app Notice lines 4-6 , 11-13 and 19-21 : we have our labels everywhere we need them. Isn't this cool? Now that you know about manifests methods interception, you may use this technique to automate many things in your manifests. Please note that method interception also works for container methods: for example, if your deployment class inherits AbstractContainerDeployment , you may intercept it's method resources() or any other method from ContainerInterrface .","title":"Manifest methods interception"},{"location":"methods-interception/#manifest-methods-interception","text":"Sometimes defining Kubernetes manifests involves code repetition, and you have to do the same repetitive job again and again. For example - you almost always have to define metadata labels at the top level of deployment manifest ( metadata.labels ), in pod spec template ( spec.template.metadata.labels ), and then section spec.selector.matchLabels should contain same labels. Thus you need copy-paste same labels 3 times every time you write a manifest. It would be great if there was a way to automate such repetitive tasks, and manifests methods interception is a way to do that in K8S Framework. Dealroadshow K8S Framework uses Proxy pattern to wrap every instance of your manifest classes into a proxy-object. Then, when manifests are processed , all methods of your manifests classes are called on proxy objects. This proxy objects wrap every method of original manifest instance in order to dispatch events before and after calling original methods, thus allowing you to intercept any method call. K8S Framework uses PSR-14 EventDispatcherInterface in order to dispatch all events, and K8S Bundle uses Symfony Event Dispatcher component that implements this interface. Before every manifest method call ManifestMethodEvent is dispatched. After manifest method was called, ManifestMethodCalledEvent is dispatched. Among other things, you then may replace method's return value in event subscriber . Let's demonstrate possibilities of methods interceptions by automating the definition of selector.matchLabels and metadata.labels sections in all manifests, so that you don't have to write those ever again. For that, we will define event subscriber class SelectorLabelsSubscriber in a standard Symfony project location src/EventListener : src/EventListener/SelectorLabelSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class SelectorLabelsSubscriber implements EventSubscriberInterface { public function onManifestMethod(ManifestMethodEvent $event): void { $methodName = $event->methodName(); $params = $event->methodParams(); $manifest = $event->manifest(); if ('selector' !== $methodName || !($manifest instanceof DeploymentInterface)) { // It's either not `selector()` method call, or not deployment's method being called return; } /** @var SelectorConfigurator $selector */ $selector = $params['selector']; /** @var AppInterface $app */ $app = PropertyAccessUtil::getPropertyValue($manifest, 'app'); $selector ->addLabel('app', $app->alias()) ->addLabel('component', $manifest::shortName()) ; } public static function getSubscribedEvents(): array { return [ ManifestMethodEvent::NAME => 'onManifestMethod' ]; } } As we see, our class implements Symfony's native EventSubscriberInterface , so thanks to autoconfiguration, just defining this class and implementing method getSubscribedEvents() as above is enough for it to recieve event every time manifest's method is about to be called. All logic of interception resides in method onManifestMethod() , which recieves events, so let's analyze it: lines 8-10 : we are checking if method being called is called selector , and if that manifest, on which this method is about to be called, is an instance of DeploymentInterface . If one of this conditions is false, we do nothing. Thus we are limiting our event subscriber to calls of method selector() on deployments. line 14 : event object contains all parameters, passed to method being called. Method DeploymentInterface::selector() must recieve SelectorConfigurator instance as $selector argument, so we getting it from array of method params. line 17 : there is no method that returns app in ManifestInterface , but any manifest that inherits K8S Framework's corresponding abstract classes (like AbstractDeployment for deployments) inherits property $app that contains app instance. Since this property is protected , we use Dealroadshow\\Bundle\\K8SBundle\\Util\\PropertyAccessUtil class to retrieve it from manifest instance. lines 19-22 : we are using $selector argument of DeploymentInterface::selector() method to define two labels: app , that contains our app alias , and component , which contains short name of the deployment. Thus any generated deployment will have selector labels automatically. K8S Framework copies all labels from selector.matchLabels to metadata.labels and spec.template.metadata.labels sections automatically - so you'll never have to write this labels again in your deployments - all thanks to one event subscriber. K8S Bundle also has predefined abstract classes that you may inherit from if you want to intercept manifest's methods: AbstractMethodSubscriber and AbstractMethodResultSubscriber - for intercepting method before it was called, or after, respectively. Below is a new version of our SelectorLabelsSubscriber that inherits AbstractMethodSubscriber : src/EventListener/SelectorLabelSubscriber.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class SelectorLabelsSubscriber extends AbstractMethodSubscriber { protected function supports(ManifestMethodEvent $event): bool { return 'selector' === $event->methodName() && $event->manifest() instanceof DeploymentInterface; } protected function beforeMethod(ManifestMethodEvent $event): void { /** @var SelectorConfigurator $selector */ $selector = $event->methodParams()['selector']; $manifest = $event->manifest(); /** @var AppInterface $app */ $app = PropertyAccessUtil::getPropertyValue($manifest, 'app'); $selector ->addLabel('app', $app->alias()) ->addLabel('component', $manifest::shortName()) ; } } This class is pretty self-explanatory now: method supports() is used to determine whether this subscriber should be called for the given event. Method beforeMethod() (for method result subscribers - afterMethod() ) then does the real job, if supports() returned true. Now that we have our subscriber, let's test it. First, let's define a simplest possible deployment class ExampleDeployment in ExampleApp : src/Example/Manifest/ExampleDeployment.php class ExampleDeployment extends AbstractContainerDeployment { public function image(): Image { return Image::fromName('my-cool/image'); } public static function shortName(): string { return 'example'; } } Now we can call console command to dump manifests into YAML files: bin/console k8s:dump:all After command finished, let's look what YAML was generated from our ExampleDeployment class: example/example.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion : apps/v1 kind : Deployment metadata : labels : app : example component : example name : example-example spec : replicas : 1 selector : matchLabels : app : example component : example template : metadata : annotations : dealroadshow.com/env-sources-checksum : d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum : d41d8cd98f00b204e9800998ecf8427e labels : app : example component : example spec : containers : - image : my-cool/image imagePullPolicy : IfNotPresent name : app Notice lines 4-6 , 11-13 and 19-21 : we have our labels everywhere we need them. Isn't this cool? Now that you know about manifests methods interception, you may use this technique to automate many things in your manifests. Please note that method interception also works for container methods: for example, if your deployment class inherits AbstractContainerDeployment , you may intercept it's method resources() or any other method from ContainerInterrface .","title":"Manifest methods interception"},{"location":"reusable-apps/","text":"Reusable apps distribution You've probably heard about Helm charts as a simple way of getting some functionality for applications that use Kubernetes - whether you need simple MySQL database or big RabbitMQ cluster - you can just choose a dedicated Helm chart for that, and Helm will generate Kubernetes manifests for that software. You also can configure some values in your charts to change default behavior. K8S Framework does not define it's own artifact hub, since all that you need already exists in PHP ecosystem: PHP has Composer , one of the greatest package manages among all programming languages, and Symfony has it's excellent bundle system that allows to install some functionality to Symfony via Composer. So if you want to create distributable reusable artifact for K8S Framework, here are the simple steps for that: Create a K8S Framework app , for example MySQLApp . Package it into a Symfony Bundle . Publish your bundle using Packagist After that everyone can install your reusable app using Composer: composer require your-nickname/mysql-app-k8s If you are writing reusable app, you probably want to define some friendly configuration for the Symfony bundle it comes with and use this configuration to tweak manifests. You can read about manifests configuration here .","title":"Distribute your apps"},{"location":"reusable-apps/#reusable-apps-distribution","text":"You've probably heard about Helm charts as a simple way of getting some functionality for applications that use Kubernetes - whether you need simple MySQL database or big RabbitMQ cluster - you can just choose a dedicated Helm chart for that, and Helm will generate Kubernetes manifests for that software. You also can configure some values in your charts to change default behavior. K8S Framework does not define it's own artifact hub, since all that you need already exists in PHP ecosystem: PHP has Composer , one of the greatest package manages among all programming languages, and Symfony has it's excellent bundle system that allows to install some functionality to Symfony via Composer. So if you want to create distributable reusable artifact for K8S Framework, here are the simple steps for that: Create a K8S Framework app , for example MySQLApp . Package it into a Symfony Bundle . Publish your bundle using Packagist After that everyone can install your reusable app using Composer: composer require your-nickname/mysql-app-k8s If you are writing reusable app, you probably want to define some friendly configuration for the Symfony bundle it comes with and use this configuration to tweak manifests. You can read about manifests configuration here .","title":"Reusable apps distribution"},{"location":"vision/","text":"Dealroadshow K8S Framework vision You may ask, why Dealroadshow K8S Framework was created, when there are such awesome tools with similar specific, as Helm , Amazon CDK8S and Pulumi Kubernetes , and what is the difference between K8S Framework and this tools. Those questions are discussed below. What is Dealroadshow K8S Dealroadshow K8S Framework and Dealroadshow K8S Bundle together form a tool that allows developers to define Kubernetes manifests using PHP and Symfony Framework - one of the best general-purpose frameworks. Tip Below in the text combination of Dealroadshow K8S Framework and Dealroadshow K8S Bundle is referred as \"K8s framework\". K8S framework focuses on declarativeness , developer productivity and constitutes our attempt to bring best practices from \"software developers world\" to \"DevOps / SRE world\". Declarativeness In order to define manifest - just define a PHP class for it. Simple class with a flat structure allows you to generate complex YAML manifest with many nested levels. You can understand how your manifest will look like by looking at this PHP class. Developer productivity K8S Framework allows to generate skeleton classes for almost any Kubernetes resource you may need. For example, to define a simple manifest class, just use Symfony console command for that: bin/console k8s:generate:manifest my-manifest-name Follow instructions in this command, and your ready-to-go class will be generated. K8S Framework also uses simple conventions (like this or this , that help you to define any manifest you want by simply following your knowledge of Kubernetes itself and the hints your IDE gives you. Tip By the way, dude - don't be a dinosaur, use a good IDE - it's NOT an advertisement. Using good IDE for the programming language of your choice makes you many times more productive, and a process of your work is much more enjoyable. Don't follow \"conservatives\" who say \"I do everything in Notepad / Vim / Emacs / Atom\" - it's just not cool in 2022. PHP has strict types comparing to other dynamic languages, so you have both productivity of work with interpretable programming language and the level of IDE analysis comparable to compiled language. When using K8S Framework and Symfony - IDE is your best friend and can hint you nearly everything. K8S framework itself decreases possibilities of an error in your manifests on early stages - for example your manifests generation command (which itself is Symfony application) will quickly fail if your classes lack of methods, required for your manifests to be valid; arguments in methods of your manifest classes are limiting you to a strict set of valid choices and so on. Symfony's approaches to structuring your code, such as autowiring make development easy and productive. Usage of a full-fledged framework itself frees your from searching tools for many common tasks, such as configuring your application , environments management , defining console commands etc. K8S Framework compared to other tools K8S Framework and Helm Helm is a tool that helps you to define, install, and upgrade Kubernetes applications. So generating Kubernetes manifests is one of it's responsibilities, while it's the only responsibility of K8S Framework, and K8S framework aims to be the best tool for that. The downside of defining manifests using Helm is the fact that you are writing an application using template language instead of programming language : you define templates using Go templates language . It's not uncommon to use conditionals, loops, functions etc in your templates. After some time, your Helm chart becomes a big application that generates YAML manifests. But instead of being written using programming language, it's written using template language without using OOP , proper code structuring, programming patterns, helpful libraries and many other good things. Often Helm templates are using so much template language that they become barely readable even by their author. Therefore the obvious solution to this issue is to write application using programming language. That is where K8S Framework comes in hand. But since you still need a tool to deploy your software to Kubernetes cluster, upgrade and rollback it, and Helm being a good tool for that - you may use Helm together with K8S Framework: K8S generates manifests, and Helm deploys them. K8S Framework and cdk8s K8S Framework is a pretty similar tool to cdk8s . They both aim to be the best tool for defining manifests using programming code and both focus only on that task, leaving responsibility to deploy and upgrade generated manifests toother tools. Also they both built their abstractions on top of code, automatically generated from Kubernetes API specs ( k8s-resources library for K8S Framework), in order to always stay relevant and to keep up with new Kubernetes versions. The first difference between this tools is languages they support. cdk8s supports few different languages, such as Python, Go, Typescript etc., while K8S Framework is a tool for PHP developers and / or DevOps / Site Reliability engineers, familiar with PHP. Since PHP is still often undeservedly hated by \"old-school sysadmins\", it probably should not be used if in your company Kubernetes manifests is a responsibility of sysadmins / DevOps specialists instead of software developers. The fact that K8S framework is designed to be used with Symfony is both it's upside and downside comparing to cdk8s and Pulumi: on the one hand, Symfony simplifies so many general-purpose tasks, such as application configuration, environments management, code structuring etc. that you would need to implement yourself if you use cdk8s. Symfony also has one of the best implementations of Dependency Injection pattern among all programming languages, comparable only with the implementation in Spring Java framework. And once you tried what application development with Dependency Injection feels like, there is no way back. Javascript and Typescript (languages, most often used with cdk8s), on the other hand, don't have really good implementations of Dependency Injection pattern and are limited with few DI surrogates. This makes depelopment and maintainance big applications using Javascript harder, and big Javascript applications more often become a mess. Note for Javascript developers In no way do we want to offend Javascript developers, so don't you start to talk about our mother: there are plenty of great applications, written in Javascript, and developer experience means much more than the choice of language. It's just general rule that using Inversion of Control principle / Dependency Injection pattern is better than not using it. On the other hand, if you are not PHP / Symfony developer and don't plan to use this language anywhere, learning new programming language and a big framework only to define Kubernetes manifests is an overkill. This fact narrows the usage scope of K8S Framework comparing to cdk8s, which supports many different languages. As a general rule - use K8S Framework if your product is written using PHP and developers write Kubernetes manifests (or planning to start doing so) in your company. Use cdk8s otherwise. K8S Framework and Pulumi Since Pulumi supports different programming languages, samely as cdk8s, and most often used with Javascript / Typescript - the same upsides and downsides as in case with cdk8s apply to it. Combining the best of both worlds Above we mentioned that K8S Framework is an attempt to bring best practices from \"software developers world\" to \"DevOps / SRE world\". Symfony Framework, on which shoulders K8S Framework is standing, brings such important things, as Inversion of Control principle, Dependency Injection pattern, mentioned above, and many other best practices and patterns. It's good if your team consists of both developers and DevOps engineers - this way by using K8S Framework and Symfony DevOps engineers will learn many useful programming techniques, and will be able to use this knowledge when working on Infrastructure as a code and other tasks. Developers, on the other hand, will deepen their knowledge of Kubernetes, IaC and other topics. Not only should we bring the best things from \"developer's world\" to \"SRE's world\", it should also work the other way: we believe developers should define, how their applications will be run, e.g. they should define Kubernetes manifests and should be familiar with CI/CD pipeline that is used in your company.","title":"Our vision"},{"location":"vision/#dealroadshow-k8s-framework-vision","text":"You may ask, why Dealroadshow K8S Framework was created, when there are such awesome tools with similar specific, as Helm , Amazon CDK8S and Pulumi Kubernetes , and what is the difference between K8S Framework and this tools. Those questions are discussed below.","title":"Dealroadshow K8S Framework vision"},{"location":"vision/#what-is-dealroadshow-k8s","text":"Dealroadshow K8S Framework and Dealroadshow K8S Bundle together form a tool that allows developers to define Kubernetes manifests using PHP and Symfony Framework - one of the best general-purpose frameworks. Tip Below in the text combination of Dealroadshow K8S Framework and Dealroadshow K8S Bundle is referred as \"K8s framework\". K8S framework focuses on declarativeness , developer productivity and constitutes our attempt to bring best practices from \"software developers world\" to \"DevOps / SRE world\".","title":"What is Dealroadshow K8S"},{"location":"vision/#declarativeness","text":"In order to define manifest - just define a PHP class for it. Simple class with a flat structure allows you to generate complex YAML manifest with many nested levels. You can understand how your manifest will look like by looking at this PHP class.","title":"Declarativeness"},{"location":"vision/#developer-productivity","text":"K8S Framework allows to generate skeleton classes for almost any Kubernetes resource you may need. For example, to define a simple manifest class, just use Symfony console command for that: bin/console k8s:generate:manifest my-manifest-name Follow instructions in this command, and your ready-to-go class will be generated. K8S Framework also uses simple conventions (like this or this , that help you to define any manifest you want by simply following your knowledge of Kubernetes itself and the hints your IDE gives you. Tip By the way, dude - don't be a dinosaur, use a good IDE - it's NOT an advertisement. Using good IDE for the programming language of your choice makes you many times more productive, and a process of your work is much more enjoyable. Don't follow \"conservatives\" who say \"I do everything in Notepad / Vim / Emacs / Atom\" - it's just not cool in 2022. PHP has strict types comparing to other dynamic languages, so you have both productivity of work with interpretable programming language and the level of IDE analysis comparable to compiled language. When using K8S Framework and Symfony - IDE is your best friend and can hint you nearly everything. K8S framework itself decreases possibilities of an error in your manifests on early stages - for example your manifests generation command (which itself is Symfony application) will quickly fail if your classes lack of methods, required for your manifests to be valid; arguments in methods of your manifest classes are limiting you to a strict set of valid choices and so on. Symfony's approaches to structuring your code, such as autowiring make development easy and productive. Usage of a full-fledged framework itself frees your from searching tools for many common tasks, such as configuring your application , environments management , defining console commands etc.","title":"Developer productivity"},{"location":"vision/#k8s-framework-compared-to-other-tools","text":"","title":"K8S Framework compared to other tools"},{"location":"vision/#k8s-framework-and-helm","text":"Helm is a tool that helps you to define, install, and upgrade Kubernetes applications. So generating Kubernetes manifests is one of it's responsibilities, while it's the only responsibility of K8S Framework, and K8S framework aims to be the best tool for that. The downside of defining manifests using Helm is the fact that you are writing an application using template language instead of programming language : you define templates using Go templates language . It's not uncommon to use conditionals, loops, functions etc in your templates. After some time, your Helm chart becomes a big application that generates YAML manifests. But instead of being written using programming language, it's written using template language without using OOP , proper code structuring, programming patterns, helpful libraries and many other good things. Often Helm templates are using so much template language that they become barely readable even by their author. Therefore the obvious solution to this issue is to write application using programming language. That is where K8S Framework comes in hand. But since you still need a tool to deploy your software to Kubernetes cluster, upgrade and rollback it, and Helm being a good tool for that - you may use Helm together with K8S Framework: K8S generates manifests, and Helm deploys them.","title":"K8S Framework and Helm"},{"location":"vision/#k8s-framework-and-cdk8s","text":"K8S Framework is a pretty similar tool to cdk8s . They both aim to be the best tool for defining manifests using programming code and both focus only on that task, leaving responsibility to deploy and upgrade generated manifests toother tools. Also they both built their abstractions on top of code, automatically generated from Kubernetes API specs ( k8s-resources library for K8S Framework), in order to always stay relevant and to keep up with new Kubernetes versions. The first difference between this tools is languages they support. cdk8s supports few different languages, such as Python, Go, Typescript etc., while K8S Framework is a tool for PHP developers and / or DevOps / Site Reliability engineers, familiar with PHP. Since PHP is still often undeservedly hated by \"old-school sysadmins\", it probably should not be used if in your company Kubernetes manifests is a responsibility of sysadmins / DevOps specialists instead of software developers. The fact that K8S framework is designed to be used with Symfony is both it's upside and downside comparing to cdk8s and Pulumi: on the one hand, Symfony simplifies so many general-purpose tasks, such as application configuration, environments management, code structuring etc. that you would need to implement yourself if you use cdk8s. Symfony also has one of the best implementations of Dependency Injection pattern among all programming languages, comparable only with the implementation in Spring Java framework. And once you tried what application development with Dependency Injection feels like, there is no way back. Javascript and Typescript (languages, most often used with cdk8s), on the other hand, don't have really good implementations of Dependency Injection pattern and are limited with few DI surrogates. This makes depelopment and maintainance big applications using Javascript harder, and big Javascript applications more often become a mess. Note for Javascript developers In no way do we want to offend Javascript developers, so don't you start to talk about our mother: there are plenty of great applications, written in Javascript, and developer experience means much more than the choice of language. It's just general rule that using Inversion of Control principle / Dependency Injection pattern is better than not using it. On the other hand, if you are not PHP / Symfony developer and don't plan to use this language anywhere, learning new programming language and a big framework only to define Kubernetes manifests is an overkill. This fact narrows the usage scope of K8S Framework comparing to cdk8s, which supports many different languages. As a general rule - use K8S Framework if your product is written using PHP and developers write Kubernetes manifests (or planning to start doing so) in your company. Use cdk8s otherwise.","title":"K8S Framework and cdk8s"},{"location":"vision/#k8s-framework-and-pulumi","text":"Since Pulumi supports different programming languages, samely as cdk8s, and most often used with Javascript / Typescript - the same upsides and downsides as in case with cdk8s apply to it.","title":"K8S Framework and Pulumi"},{"location":"vision/#combining-the-best-of-both-worlds","text":"Above we mentioned that K8S Framework is an attempt to bring best practices from \"software developers world\" to \"DevOps / SRE world\". Symfony Framework, on which shoulders K8S Framework is standing, brings such important things, as Inversion of Control principle, Dependency Injection pattern, mentioned above, and many other best practices and patterns. It's good if your team consists of both developers and DevOps engineers - this way by using K8S Framework and Symfony DevOps engineers will learn many useful programming techniques, and will be able to use this knowledge when working on Infrastructure as a code and other tasks. Developers, on the other hand, will deepen their knowledge of Kubernetes, IaC and other topics. Not only should we bring the best things from \"developer's world\" to \"SRE's world\", it should also work the other way: we believe developers should define, how their applications will be run, e.g. they should define Kubernetes manifests and should be familiar with CI/CD pipeline that is used in your company.","title":"Combining the best of both worlds"},{"location":"concepts/apps/","text":"Apps App is one of the basic concepts in Dealroadshow K8S Framework. You've probably already heard of Helm Charts . App in K8S Framework means the same thing - it is a collection of related manifests that will be dumped together. What are criteria of moving some set of Kubernetes resources to app? Well, this Kubernetes resources should be related , but what does related means in this context? Generally this should mean that a set of manifests must be deployed together. So you may define an app as a set of Kubernetes manifests for a single service in SOA architecture, or for a microservice in microservice architecture. If you have a big monolith platform - you are probably thinking on how to split it into smaller pieces, which can be deployed separately. The same criteria may apply to corresponding manifests. Every app must implement AppInterface . Let's see what method this interface defines: interface AppInterface extends ConfigurableInterface { public static function name(): string; /** * @return string The alias with which app was registered in AppRegistry */ public function alias(): string; public function addManifestFile(string $fileNameWithoutExtension, APIResourceInterface $resource): void; public function metadataHelper(): MetadataHelperInterface; public function namesHelper(): NamesHelperInterface; public function manifestNamePrefix(): string; public function manifestConfig(string $shortName): array; /** * @return ManifestFile[] */ public function manifestFiles(): iterable; } Below, by walking through some important methods of AppInterface , we will better understand app's role. We don't discuss methods addManifestFile() , metadataHelper() , namesHelper() , manifestConfig() and manifestFiles() here - these are internal methods and they are not needed for you to understand apps. Some of this methods are discussed in other articles. Names and aliases Method AppInterface::name() defines default name of an app. What \" default \" means here? As you can see, this method is static, so different instances of an app class cannot return different names. But when do you need more than one instance of the same app class? Well, suppose you have RedisApp that contains manifests for Redis cluster: namespace K8S\\Redis; use Dealroadshow\\K8S\\Framework\\App\\AbstractApp; class RedisApp extends AbstractApp { public static function name(): string { return 'redis'; } } If you need just one Redis cluster - you don't need to configure anything. But what if you need two or more Redis clusters? It is possible to use RedisApp class to generate as many app copies as you need. All you have to do is register one RedisApp instance in AppRegistry for every cluster you want. So if you need Kubernetes manifests for two clusters - you need to register two RedisApp instances with different aliases . If you use K8S Bundle with Symfony application (recommended way of using K8S Framework ), framework will register them for you - just configure them in config/packages/dealroadshow_k8s.yaml file: dealroadshow_k8s.yaml 1 2 3 4 5 6 7 8 9 dealroadshow_k8s : apps : - alias : first-redis class : App\\K8S\\Redis\\RedisApp - alias : second-redis class : App\\K8S\\Redis\\RedisApp - alias : redis class : App\\K8S\\Redis\\RedisApp enabled : false # You need to explicitly disable app registration by it's name() method Important Please note lines 7-9 in config above: we register two apps, first-redis and second-redis with RedisApp class, but without lines 7-9 there will be third app redis - class RedisApp will be found by Symfony DI as any other app class and will be added by it's name redis . So in order to avoid \"default\" app registration - register it explicitly by name, returned from app's method name() , and add option enabled: false . So alias is a dynamic app name, that allows to have many different instances of the same app class with different names. And since by manifests naming convention all manifest names are prefixed with app alias - this ensures that there will be no two manifests with the same name when you generate two copies of an app. Let's demonstrate this with example. Suppose you have class ClusterStatefulSet in your RedisApp : namespace K8S\\Redis\\Manifest; // ... class ClusterStatefulSet extends AbstractContainerStatefulSet { public static function shortName(): string { return 'cluster'; } // other methods } If you need just one Redis cluster and you did not configure any aliases in config file - Symfony will find your RedisApp class, and will create and register instance by alias, taken from RedisApp::name() method - thus when you dump manifests you'll have directory redis and manifest file redis/cluster.stateful-set.yaml : redis/cluster.stateful-set.yaml 1 2 3 4 5 6 7 8 apiVersion : apps/v1 kind : StatefulSet metadata : labels : app : redis component : cluster name : redis-cluster # ... As you see, StatefulSet will have name redis-cluster . However, if you configure two aliases like shown above, after dumping manifests you'll have directories first-redis and second-redis , files first-redis/cluster.stateful-set.yaml and second-redis/cluster.stateful-set.yaml with corresponding names first-redis-cluster and second-redis-cluster . Generating manifest only for a subset of apps Suppose we have configured few instances of our RedisApp like in example above. Then, suppose we have some manifest class that we want to be generated only for second-redis app, but not for first-redis . This is easily done by using EnabledForApps PHP attribute that comes with K8S Framework: #[EnabledForApps('second-redis')] class MyExclusiveDeployment extends AbstractContainerDeployment { public static function shortName(): string { return 'exclusive'; } // ... } As a result, there will be generated file second-redis/exclusive.deployment.yaml but no first-redis/exclusive.deployment.yaml . Accessing app alias inside manifest classes Sometimes you need app alias in a manifest class. As mentioned in Manifests article, you may access app instance in any manifest by inherited property $app . So when you need app alias, access it like $this->app->alias() : class ClusterStatefulSet extends AbstractContainerStatefulSet { public function selector(SelectorConfigurator $selector): void { $selector ->addLabel('app', $this->app->alias()) ->addLabel('component', static::shortName()) ; } // other methods } Every app instance will have it's alias injected by K8S framework, so feel free to use method AppInterface::alias() on any app object. Summary So, to summarize information about app names and aliases: in most of cases you don't need to configure app with aliases - by default they will be registered by their name, and alias will be the same as name. Configure app class with different aliases if you need more than one copy of the app generated. Configuring manifest name prefixes Method AppInterface::manifestNamePrefix() is implemented in AbstractApp class and makes default naming convention work: AbstractApp.php public function manifestNamePrefix(): string { return $this->alias; } This method result is then used in DefaultNamesHelper class, which generates names for Kubernetes resources during manifests generation. It means that if you don't want your resource names to be prefixed with app names - just return an empty string from this method in your app class. Please read dedicated article if you want to change naming convention entirely. App's directory structure Console command k8s:generate:app that comes with K8S Bundle generates app class and certain directory structure, which is a recommended but not mandatory way to structure your apps. By default your generated app will look like follows: Let's take a closer look at this structure. Every app class is stored in a dedicated directory / namespace, for example HelloApp class will be stored in K8S\\Hello namespace, RedisApp - in K8S\\Redis namespace and so on. At top level of app directory there is app class itself and few nested directories. Container dir Store your container classes in this directory. Note that this does not applies to Container -prefixed manifest classes, like classes that inherit from AbstractContainerDeployment . Most of the time you don't have separate container classes, so this directory is often deleted from generated app skeleton. Manifest dir This is a most important directory in your app, since you should create your manifest classes in it. You may want to have some nested directories here, like Manifest\\Deployments , Manifest\\ConfigMaps and so on - feel free to create directory structure you like - Symfony and K8S framework will find and register your manifest classes by interfaces they implement, not by some exact file location. Resources dir If your app class extends AbstractApp , it will have method readFile() . Suppose your app has a deployment for some web service, and you want to mount config for your Nginx webserver from some ConfigMap . If you store nginx config in your ConfigMap class like string literal - it would be ugly. Instead you can store your nginx config as Resources/nginx.conf and then use method AbstractApp::readFile() to store it in your ConfigMap: class NginxConfigMap extends AbstractConfigMap { public function data(StringMap $data): void { $data->add('config', $this->app->readFile('nginx.conf')); } public static function shortName(): string { return 'nginx'; } } You may even want to implement more complex logic in your app class, for example method compileTemplate() - like if you want your nginx config to be generated from Twig template. In any of such scenarios, Resources dir is a place to store auxiliary files for your manifests. Summary In this article we got to know concept of apps better. If you did not yet read about containers - you should probably get to that article. You may also be interested in general lifecycle of manifest generation application.","title":"Apps"},{"location":"concepts/apps/#apps","text":"App is one of the basic concepts in Dealroadshow K8S Framework. You've probably already heard of Helm Charts . App in K8S Framework means the same thing - it is a collection of related manifests that will be dumped together. What are criteria of moving some set of Kubernetes resources to app? Well, this Kubernetes resources should be related , but what does related means in this context? Generally this should mean that a set of manifests must be deployed together. So you may define an app as a set of Kubernetes manifests for a single service in SOA architecture, or for a microservice in microservice architecture. If you have a big monolith platform - you are probably thinking on how to split it into smaller pieces, which can be deployed separately. The same criteria may apply to corresponding manifests. Every app must implement AppInterface . Let's see what method this interface defines: interface AppInterface extends ConfigurableInterface { public static function name(): string; /** * @return string The alias with which app was registered in AppRegistry */ public function alias(): string; public function addManifestFile(string $fileNameWithoutExtension, APIResourceInterface $resource): void; public function metadataHelper(): MetadataHelperInterface; public function namesHelper(): NamesHelperInterface; public function manifestNamePrefix(): string; public function manifestConfig(string $shortName): array; /** * @return ManifestFile[] */ public function manifestFiles(): iterable; } Below, by walking through some important methods of AppInterface , we will better understand app's role. We don't discuss methods addManifestFile() , metadataHelper() , namesHelper() , manifestConfig() and manifestFiles() here - these are internal methods and they are not needed for you to understand apps. Some of this methods are discussed in other articles.","title":"Apps"},{"location":"concepts/apps/#names-and-aliases","text":"Method AppInterface::name() defines default name of an app. What \" default \" means here? As you can see, this method is static, so different instances of an app class cannot return different names. But when do you need more than one instance of the same app class? Well, suppose you have RedisApp that contains manifests for Redis cluster: namespace K8S\\Redis; use Dealroadshow\\K8S\\Framework\\App\\AbstractApp; class RedisApp extends AbstractApp { public static function name(): string { return 'redis'; } } If you need just one Redis cluster - you don't need to configure anything. But what if you need two or more Redis clusters? It is possible to use RedisApp class to generate as many app copies as you need. All you have to do is register one RedisApp instance in AppRegistry for every cluster you want. So if you need Kubernetes manifests for two clusters - you need to register two RedisApp instances with different aliases . If you use K8S Bundle with Symfony application (recommended way of using K8S Framework ), framework will register them for you - just configure them in config/packages/dealroadshow_k8s.yaml file: dealroadshow_k8s.yaml 1 2 3 4 5 6 7 8 9 dealroadshow_k8s : apps : - alias : first-redis class : App\\K8S\\Redis\\RedisApp - alias : second-redis class : App\\K8S\\Redis\\RedisApp - alias : redis class : App\\K8S\\Redis\\RedisApp enabled : false # You need to explicitly disable app registration by it's name() method Important Please note lines 7-9 in config above: we register two apps, first-redis and second-redis with RedisApp class, but without lines 7-9 there will be third app redis - class RedisApp will be found by Symfony DI as any other app class and will be added by it's name redis . So in order to avoid \"default\" app registration - register it explicitly by name, returned from app's method name() , and add option enabled: false . So alias is a dynamic app name, that allows to have many different instances of the same app class with different names. And since by manifests naming convention all manifest names are prefixed with app alias - this ensures that there will be no two manifests with the same name when you generate two copies of an app. Let's demonstrate this with example. Suppose you have class ClusterStatefulSet in your RedisApp : namespace K8S\\Redis\\Manifest; // ... class ClusterStatefulSet extends AbstractContainerStatefulSet { public static function shortName(): string { return 'cluster'; } // other methods } If you need just one Redis cluster and you did not configure any aliases in config file - Symfony will find your RedisApp class, and will create and register instance by alias, taken from RedisApp::name() method - thus when you dump manifests you'll have directory redis and manifest file redis/cluster.stateful-set.yaml : redis/cluster.stateful-set.yaml 1 2 3 4 5 6 7 8 apiVersion : apps/v1 kind : StatefulSet metadata : labels : app : redis component : cluster name : redis-cluster # ... As you see, StatefulSet will have name redis-cluster . However, if you configure two aliases like shown above, after dumping manifests you'll have directories first-redis and second-redis , files first-redis/cluster.stateful-set.yaml and second-redis/cluster.stateful-set.yaml with corresponding names first-redis-cluster and second-redis-cluster .","title":"Names and aliases"},{"location":"concepts/apps/#generating-manifest-only-for-a-subset-of-apps","text":"Suppose we have configured few instances of our RedisApp like in example above. Then, suppose we have some manifest class that we want to be generated only for second-redis app, but not for first-redis . This is easily done by using EnabledForApps PHP attribute that comes with K8S Framework: #[EnabledForApps('second-redis')] class MyExclusiveDeployment extends AbstractContainerDeployment { public static function shortName(): string { return 'exclusive'; } // ... } As a result, there will be generated file second-redis/exclusive.deployment.yaml but no first-redis/exclusive.deployment.yaml .","title":"Generating manifest only for a subset of apps"},{"location":"concepts/apps/#accessing-app-alias-inside-manifest-classes","text":"Sometimes you need app alias in a manifest class. As mentioned in Manifests article, you may access app instance in any manifest by inherited property $app . So when you need app alias, access it like $this->app->alias() : class ClusterStatefulSet extends AbstractContainerStatefulSet { public function selector(SelectorConfigurator $selector): void { $selector ->addLabel('app', $this->app->alias()) ->addLabel('component', static::shortName()) ; } // other methods } Every app instance will have it's alias injected by K8S framework, so feel free to use method AppInterface::alias() on any app object.","title":"Accessing app alias inside manifest classes"},{"location":"concepts/apps/#summary","text":"So, to summarize information about app names and aliases: in most of cases you don't need to configure app with aliases - by default they will be registered by their name, and alias will be the same as name. Configure app class with different aliases if you need more than one copy of the app generated.","title":"Summary"},{"location":"concepts/apps/#configuring-manifest-name-prefixes","text":"Method AppInterface::manifestNamePrefix() is implemented in AbstractApp class and makes default naming convention work: AbstractApp.php public function manifestNamePrefix(): string { return $this->alias; } This method result is then used in DefaultNamesHelper class, which generates names for Kubernetes resources during manifests generation. It means that if you don't want your resource names to be prefixed with app names - just return an empty string from this method in your app class. Please read dedicated article if you want to change naming convention entirely.","title":"Configuring manifest name prefixes"},{"location":"concepts/apps/#apps-directory-structure","text":"Console command k8s:generate:app that comes with K8S Bundle generates app class and certain directory structure, which is a recommended but not mandatory way to structure your apps. By default your generated app will look like follows: Let's take a closer look at this structure. Every app class is stored in a dedicated directory / namespace, for example HelloApp class will be stored in K8S\\Hello namespace, RedisApp - in K8S\\Redis namespace and so on. At top level of app directory there is app class itself and few nested directories.","title":"App's directory structure"},{"location":"concepts/apps/#container-dir","text":"Store your container classes in this directory. Note that this does not applies to Container -prefixed manifest classes, like classes that inherit from AbstractContainerDeployment . Most of the time you don't have separate container classes, so this directory is often deleted from generated app skeleton.","title":"Container dir"},{"location":"concepts/apps/#manifest-dir","text":"This is a most important directory in your app, since you should create your manifest classes in it. You may want to have some nested directories here, like Manifest\\Deployments , Manifest\\ConfigMaps and so on - feel free to create directory structure you like - Symfony and K8S framework will find and register your manifest classes by interfaces they implement, not by some exact file location.","title":"Manifest dir"},{"location":"concepts/apps/#resources-dir","text":"If your app class extends AbstractApp , it will have method readFile() . Suppose your app has a deployment for some web service, and you want to mount config for your Nginx webserver from some ConfigMap . If you store nginx config in your ConfigMap class like string literal - it would be ugly. Instead you can store your nginx config as Resources/nginx.conf and then use method AbstractApp::readFile() to store it in your ConfigMap: class NginxConfigMap extends AbstractConfigMap { public function data(StringMap $data): void { $data->add('config', $this->app->readFile('nginx.conf')); } public static function shortName(): string { return 'nginx'; } } You may even want to implement more complex logic in your app class, for example method compileTemplate() - like if you want your nginx config to be generated from Twig template. In any of such scenarios, Resources dir is a place to store auxiliary files for your manifests.","title":"Resources dir"},{"location":"concepts/apps/#summary_1","text":"In this article we got to know concept of apps better. If you did not yet read about containers - you should probably get to that article. You may also be interested in general lifecycle of manifest generation application.","title":"Summary"},{"location":"concepts/containers/","text":"Containers Containers are the heart of any workload . No matter what workload type are you dealing with ( Deployment , Job , StatefulSet etc.), you'll have to define containers for it - but the good news is that container API object is the same for any workload, so you'll need to learn it once and use in any manifest. All containers in K8S Framework must implement ContainerInterface . Containers returned from method containers() in workload. You may return array of them, or (which looks better) use yield keyword, for examle: public function containers(): iterable { yield new PhpFpmContainer(); yield new NginxContainer(); } Also every workload type has Container -prefixed abstract class, which is a recommended way of writing your manifest: for example, there is AbstractDeplyment class that you may inherit, but there is also Container -prefixed class AbstractContainerDeployment , which implements both DeploymentInterface and ContainerInterface - by inheriting this class, you'll make your manifest much more descriptive - define your \"main\" container methods in deployment class itself, and if you also need some auxiliary containers - rewrite containers() method amd return them as well. For example, if your deployment ExampleDeployment has php-fpm and nginx containers - just extend AbstractContainerDeployment class, define php-fpm container method in ExampleDeployment itself (since php-fpm holds your application code and may be considered as \"main\" container), and that rewrite your containers() method as follows: class ExampleDeployment extends AbstractContainerDeployment { public function containers(): iterable { yield $this; yield new NginxContainer(); } //... } Separate container classes, like NginxContainer from example above, should be defined in Container namespace inside your app. Tip App's directory structure is explained in Apps article. Since every container class must implement ContainerInterface , there is an abstract class AbstractContainer for you, which helps you with that by defining most of the methods from ContainerInterface with reasonable defaults. You then just have to modify what should be modified: namespace App\\K8S\\Hello\\Container; use Dealroadshow\\K8S\\Framework\\Core\\Container\\AbstractContainer; use Dealroadshow\\K8S\\Framework\\Core\\Container\\Image\\Image; class NginxContainer extends AbstractContainer { public function image(): Image { return Image::fromName('nginx'); } } This is a perfectly valid container class. AbstractContainer requires from you to define only image() method. Container images All containers are created from images, so every container needs one. Defining image your container will use is as simple as defining image() method in your manifest, as shown in the example above. As you see, this method must return instance of Image class. Image is a pretty easey to use value-object. Basically, you can just use one of the static constructors: Image::fromName() or Image::fromString() . The difference between two is that Image::fromString expects full image information as parameter - along with repository url, image tag and so on. For example, if you image is stored in AWS ECR and you want to deploy tag 1.2.3 of your my-organization/cool-application image, your method image() may look as follows: public function image(): Image { return Image::fromString( '49367101234912.dkr.ecr.us-east-1.amazonaws.com/my-organization/cool-application:1.2.3' ); } If you prefer using Image::fromName() constructor, this is how method image() would like if you want to return the same image as above: public function image(): Image { return Image::fromName('cool-application') ->setPrefix('my-organization') ->setTag('1.2.3') ->setRegistryUrl('49367101234912.dkr.ecr.us-east-1.amazonaws.com'); } But the one thing that may come to your mind, is \"It's not cool to modify image() method to change tag every time I need to deploy new version of my application\". And you are absolutely right. This problem above is pretty easy to solve by using environment variable in code and passing this variable from whatever CI/CD tool you use. You may write setTag(getenv('MY_APPLICATION_TAG')) instead of setTag(1.2.3) in your code. But even after that - if you use Kubernetes, there are probably plenty of different images built in your organization, so you'll need to repeat setRegistryUrl() and setPrefix() parts many times. There is a solution in K8S Framework, specifically created to address issues like that. If you want to want to avoid such repetitiveness in your code - please read Images Middleware . Defining environment variables for container Passing environment variables to your containers are one of the most often used features in Kubernetes manifests. All environment variables for your container are defined in env() method. Just after your IDE have generated this method for you, it should look like follows: public function env(EnvConfigurator $env): void { } To define single env variable - use $env->var() method: Simple env variable public function env(EnvConfigurator $env): void { $env ->var('VARIABLE_NAME', 'SOME VALUE') ->var('FOO', 'Bar!'); } In Kubernetes manifests you can also define env variable that gets it's value from a plenty of different sources: Env variable from ConfigMap or Secret Env variable may get it's value from some key in ConfigMap or Secret . K8S Framework follows simple rule: You don't deal with manifest names in manifest classes , since simple typo in name of resource you want to use will lead to errors that's not immediately detectable. Instead, framework makes it easy to deal with connections between different Kubernetes resources by using their class names: public function env(EnvConfigurator $env): void { $env ->varFromConfigMap( varName: 'MY_VAR', configMapClass: SomeConfigMap::class, configMapKey: 'someKey' ) ->varFromSecret( varName: 'MY_VAR', secretClass: SomeSecret::class, secretKey: 'someKey' ) ; } Env variable from container resources Kubernetes allows you to pass your resources requests and limits as values of env variables: public function env(EnvConfigurator $env): void { $env ->varFromContainerResources( varName: 'MY_CPU_LIMITS', field: ContainerResourcesField::cpuLimits() ) ->varFromContainerResources( varName: 'MY_MEMORY_REQUESTS', field: ContainerResourcesField::memoryRequests() ) ; } Env variable from pod fields Kubernetes also allows to pass some info about pod: public function env(EnvConfigurator $env): void { $env ->varFromPod( varName: 'MY_IP', podField: PodField::podIp() ) ->varFromPod( varName: 'MY_METADATA_LABELS', podField: PodField::metadataLabels() ) ; } Import all keys from ConfigMap or Secret as env variables Sometimes you'll want to import an entire ConfigMap or Secret as env variables source. So all keys of ConfigMap or Secret will be names of environment variables: public function env(EnvConfigurator $env): void { $env ->addConfigMap(SomeConfigMap::class) ->addSecret(SomeSecret::class) ; } Or, even simpler: public function env(EnvConfigurator $env): void { $env ->addFrom(SomeConfigMap::class) ->addFromClasses( SomeOtherConfigMap::class, SomeSecret::class, SomeOtherSecret::class ) ; } Using env ConfigMaps or Secrets that are in different app Examples above will work only if ConfigMaps and Secrets you add belong to the same app as your container class . For example, if you have container class K8S\\Hello\\Container\\NginxContainer , where K8S\\Hello is your app namespace, and you are trying to add variables from K8S\\World\\Manifest\\SomeConfigMap as above - it will not work. Using env sources from other apps is considered a bad practice, since it will couple your apps, and it means that your apps are not structured correctly. But if you absolutely have to do this - here is how it's done: public function env(EnvConfigurator $env): void { $env ->withExternalApp(WorldApp::name()) ->addFrom(SomeConfigMap::class) ->withExternalApp(SomeOtherApp::name()) ->addFromClasses(YetOneConfigMap::class, YetOneSecret::class) ; } Method EnvConfigurator::withExternalApp() returns other EnvConfigurator instance, configured to look for env source classes in other app, which name you passed to this method as parameter. If it's not absolutely clear to you, what does it mean for manifest \"to belong to app\" - please read Apps article. Volumes and VolumeMounts An issue with Volumes and VolumeMounts is that VolumeMounts is a part of container specification, while Volumes are defined on pod spec level, so volumes() method is not a part of ContainerInterface . This is one more reason to use Container -prefixed workloads , such as AbstractContainerDeployment , AbstractContainerCronjob etc. By extending this classes you'll have methods volumes() and volumeMounts() in one class. Here is an example using our WorldDeployment class from Getting Started : WorldDeployment.php class WorldDeployment extends AbstractContainerDeployment { private const VOLUME_TEMP_DIR = 'temp-dir'; private const VOLUME_PHP_CONF = 'php-conf'; //... public function volumes(VolumesConfigurator $volumes): void { $volumes ->fromEmptyDir(self::VOLUME_TEMP_DIR) ->setSizeLimit(Memory::mebibytes(100)) ->useRAM(); $volumes->fromConfigMap(self::VOLUME_PHP_CONF, PhpConfigMap::class); } public function volumeMounts(VolumeMountsConfigurator $mounts): void { $mounts->add(self::VOLUME_TEMP_DIR, '/tmp'); $mounts->add(self::VOLUME_PHP_CONF, '/etc/php/'); } //... } Again, as with env sources, if ConfigMap you want to mount belongs to another app - use withExternalApp() method: public function volumes(VolumesConfigurator $volumes): void { $volumes ->withExternalApp(SomeOtherApp::name()) ->fromConfigMap(self::VOLUME_PHP_CONF, PhpConfigMap::class); } Summary Please see ContainerInterface in order to see what methods are available for you to define in this class.","title":"Containers"},{"location":"concepts/containers/#containers","text":"Containers are the heart of any workload . No matter what workload type are you dealing with ( Deployment , Job , StatefulSet etc.), you'll have to define containers for it - but the good news is that container API object is the same for any workload, so you'll need to learn it once and use in any manifest. All containers in K8S Framework must implement ContainerInterface . Containers returned from method containers() in workload. You may return array of them, or (which looks better) use yield keyword, for examle: public function containers(): iterable { yield new PhpFpmContainer(); yield new NginxContainer(); } Also every workload type has Container -prefixed abstract class, which is a recommended way of writing your manifest: for example, there is AbstractDeplyment class that you may inherit, but there is also Container -prefixed class AbstractContainerDeployment , which implements both DeploymentInterface and ContainerInterface - by inheriting this class, you'll make your manifest much more descriptive - define your \"main\" container methods in deployment class itself, and if you also need some auxiliary containers - rewrite containers() method amd return them as well. For example, if your deployment ExampleDeployment has php-fpm and nginx containers - just extend AbstractContainerDeployment class, define php-fpm container method in ExampleDeployment itself (since php-fpm holds your application code and may be considered as \"main\" container), and that rewrite your containers() method as follows: class ExampleDeployment extends AbstractContainerDeployment { public function containers(): iterable { yield $this; yield new NginxContainer(); } //... } Separate container classes, like NginxContainer from example above, should be defined in Container namespace inside your app. Tip App's directory structure is explained in Apps article. Since every container class must implement ContainerInterface , there is an abstract class AbstractContainer for you, which helps you with that by defining most of the methods from ContainerInterface with reasonable defaults. You then just have to modify what should be modified: namespace App\\K8S\\Hello\\Container; use Dealroadshow\\K8S\\Framework\\Core\\Container\\AbstractContainer; use Dealroadshow\\K8S\\Framework\\Core\\Container\\Image\\Image; class NginxContainer extends AbstractContainer { public function image(): Image { return Image::fromName('nginx'); } } This is a perfectly valid container class. AbstractContainer requires from you to define only image() method.","title":"Containers"},{"location":"concepts/containers/#container-images","text":"All containers are created from images, so every container needs one. Defining image your container will use is as simple as defining image() method in your manifest, as shown in the example above. As you see, this method must return instance of Image class. Image is a pretty easey to use value-object. Basically, you can just use one of the static constructors: Image::fromName() or Image::fromString() . The difference between two is that Image::fromString expects full image information as parameter - along with repository url, image tag and so on. For example, if you image is stored in AWS ECR and you want to deploy tag 1.2.3 of your my-organization/cool-application image, your method image() may look as follows: public function image(): Image { return Image::fromString( '49367101234912.dkr.ecr.us-east-1.amazonaws.com/my-organization/cool-application:1.2.3' ); } If you prefer using Image::fromName() constructor, this is how method image() would like if you want to return the same image as above: public function image(): Image { return Image::fromName('cool-application') ->setPrefix('my-organization') ->setTag('1.2.3') ->setRegistryUrl('49367101234912.dkr.ecr.us-east-1.amazonaws.com'); } But the one thing that may come to your mind, is \"It's not cool to modify image() method to change tag every time I need to deploy new version of my application\". And you are absolutely right. This problem above is pretty easy to solve by using environment variable in code and passing this variable from whatever CI/CD tool you use. You may write setTag(getenv('MY_APPLICATION_TAG')) instead of setTag(1.2.3) in your code. But even after that - if you use Kubernetes, there are probably plenty of different images built in your organization, so you'll need to repeat setRegistryUrl() and setPrefix() parts many times. There is a solution in K8S Framework, specifically created to address issues like that. If you want to want to avoid such repetitiveness in your code - please read Images Middleware .","title":"Container images"},{"location":"concepts/containers/#defining-environment-variables-for-container","text":"Passing environment variables to your containers are one of the most often used features in Kubernetes manifests. All environment variables for your container are defined in env() method. Just after your IDE have generated this method for you, it should look like follows: public function env(EnvConfigurator $env): void { } To define single env variable - use $env->var() method:","title":"Defining environment variables for container"},{"location":"concepts/containers/#simple-env-variable","text":"public function env(EnvConfigurator $env): void { $env ->var('VARIABLE_NAME', 'SOME VALUE') ->var('FOO', 'Bar!'); } In Kubernetes manifests you can also define env variable that gets it's value from a plenty of different sources:","title":"Simple env variable"},{"location":"concepts/containers/#env-variable-from-configmap-or-secret","text":"Env variable may get it's value from some key in ConfigMap or Secret . K8S Framework follows simple rule: You don't deal with manifest names in manifest classes , since simple typo in name of resource you want to use will lead to errors that's not immediately detectable. Instead, framework makes it easy to deal with connections between different Kubernetes resources by using their class names: public function env(EnvConfigurator $env): void { $env ->varFromConfigMap( varName: 'MY_VAR', configMapClass: SomeConfigMap::class, configMapKey: 'someKey' ) ->varFromSecret( varName: 'MY_VAR', secretClass: SomeSecret::class, secretKey: 'someKey' ) ; }","title":"Env variable from ConfigMap or Secret"},{"location":"concepts/containers/#env-variable-from-container-resources","text":"Kubernetes allows you to pass your resources requests and limits as values of env variables: public function env(EnvConfigurator $env): void { $env ->varFromContainerResources( varName: 'MY_CPU_LIMITS', field: ContainerResourcesField::cpuLimits() ) ->varFromContainerResources( varName: 'MY_MEMORY_REQUESTS', field: ContainerResourcesField::memoryRequests() ) ; }","title":"Env variable from container resources"},{"location":"concepts/containers/#env-variable-from-pod-fields","text":"Kubernetes also allows to pass some info about pod: public function env(EnvConfigurator $env): void { $env ->varFromPod( varName: 'MY_IP', podField: PodField::podIp() ) ->varFromPod( varName: 'MY_METADATA_LABELS', podField: PodField::metadataLabels() ) ; }","title":"Env variable from pod fields"},{"location":"concepts/containers/#import-all-keys-from-configmap-or-secret-as-env-variables","text":"Sometimes you'll want to import an entire ConfigMap or Secret as env variables source. So all keys of ConfigMap or Secret will be names of environment variables: public function env(EnvConfigurator $env): void { $env ->addConfigMap(SomeConfigMap::class) ->addSecret(SomeSecret::class) ; } Or, even simpler: public function env(EnvConfigurator $env): void { $env ->addFrom(SomeConfigMap::class) ->addFromClasses( SomeOtherConfigMap::class, SomeSecret::class, SomeOtherSecret::class ) ; }","title":"Import all keys from ConfigMap or Secret as env variables"},{"location":"concepts/containers/#using-env-configmaps-or-secrets-that-are-in-different-app","text":"Examples above will work only if ConfigMaps and Secrets you add belong to the same app as your container class . For example, if you have container class K8S\\Hello\\Container\\NginxContainer , where K8S\\Hello is your app namespace, and you are trying to add variables from K8S\\World\\Manifest\\SomeConfigMap as above - it will not work. Using env sources from other apps is considered a bad practice, since it will couple your apps, and it means that your apps are not structured correctly. But if you absolutely have to do this - here is how it's done: public function env(EnvConfigurator $env): void { $env ->withExternalApp(WorldApp::name()) ->addFrom(SomeConfigMap::class) ->withExternalApp(SomeOtherApp::name()) ->addFromClasses(YetOneConfigMap::class, YetOneSecret::class) ; } Method EnvConfigurator::withExternalApp() returns other EnvConfigurator instance, configured to look for env source classes in other app, which name you passed to this method as parameter. If it's not absolutely clear to you, what does it mean for manifest \"to belong to app\" - please read Apps article.","title":"Using env ConfigMaps or Secrets that are in different app"},{"location":"concepts/containers/#volumes-and-volumemounts","text":"An issue with Volumes and VolumeMounts is that VolumeMounts is a part of container specification, while Volumes are defined on pod spec level, so volumes() method is not a part of ContainerInterface . This is one more reason to use Container -prefixed workloads , such as AbstractContainerDeployment , AbstractContainerCronjob etc. By extending this classes you'll have methods volumes() and volumeMounts() in one class. Here is an example using our WorldDeployment class from Getting Started : WorldDeployment.php class WorldDeployment extends AbstractContainerDeployment { private const VOLUME_TEMP_DIR = 'temp-dir'; private const VOLUME_PHP_CONF = 'php-conf'; //... public function volumes(VolumesConfigurator $volumes): void { $volumes ->fromEmptyDir(self::VOLUME_TEMP_DIR) ->setSizeLimit(Memory::mebibytes(100)) ->useRAM(); $volumes->fromConfigMap(self::VOLUME_PHP_CONF, PhpConfigMap::class); } public function volumeMounts(VolumeMountsConfigurator $mounts): void { $mounts->add(self::VOLUME_TEMP_DIR, '/tmp'); $mounts->add(self::VOLUME_PHP_CONF, '/etc/php/'); } //... } Again, as with env sources, if ConfigMap you want to mount belongs to another app - use withExternalApp() method: public function volumes(VolumesConfigurator $volumes): void { $volumes ->withExternalApp(SomeOtherApp::name()) ->fromConfigMap(self::VOLUME_PHP_CONF, PhpConfigMap::class); }","title":"Volumes and VolumeMounts"},{"location":"concepts/containers/#summary","text":"Please see ContainerInterface in order to see what methods are available for you to define in this class.","title":"Summary"},{"location":"concepts/images-middleware/","text":"","title":"Images middleware"},{"location":"concepts/manifests/","text":"Manifests explained Prerequisites This article and any other articles in this docs assume that you use Dealroadshow K8S Bundle with a Symfony project and default Symfony configuration ( autowiring and autoconfiguration enabled). Defining manifests Defining manifest in Dealroadshow K8S Framework - means to define it's PHP class. Thanks to Symfony's autowiring and autoconfiguration, K8S framework then finds all manifest classes, processes them and dumps them to YAML files. But what classes are considered as manifests? Well, all classes, that implement ManifestInterface . Let's look at this interface: ManifestInterface.php interface ManifestInterface extends AppAwareInterface, ConfigAwareInterface, MetadataAwareInterface { public static function kind(): string; public static function shortName(): string; public function fileNameWithoutExtension(): string; } We can see three methods that this interface defines and thus every manifest must have: kind() , shortName() and fileNameWithoutExtension() . As you may have guessed, method kind() just returns good old Kubernetes kind - Deployment , Service , Secret , Ingress or any other kind that is understendable by Kubernetes itself. You will probably never define this method by yourself, since you will use abstract classes, defined by framework, such as AbstractDeployment or AbstractSecret - they all have this method defined. Method fileNameWithoutExtension() is internal and is used in order to generate filenames of dumped manifests. You don't have to define it either. Manifest names The only method you need to define in every manifest is shortName() . Method is called shortName() , not name() , because it should return part of name, \"relative\" to app. By default, full name of generated manifest will be formed as {app name}-{manifest shortName} , so for example if you have an app class HelloApp , which method HelloApp::name() returns hello , and manifest WorldDeployment , which method WorldDeployment::shortName() returns world , generated YAML file will have name hello/world.deployment.yaml and will contain deployment with name hello-world . Tip Don't worry if you don't like this naming convention. K8S framework is very flexible and allows to change this behavior. If you want to use your own naming convention for manifests - please read Change naming convention Good to know In fact, manifest names are prefixed not with app names, but with app aliases . Term \"app name\" above is a slight simplification, good enough for the most of users, since by default \"app alias\" will be equal to \"app name\". Using app object inside manifests Please look again at ManifestInterface above. You may note that this interface extends other interfaces, first of which is AppAwareInterface . This interface declares a single method - setApp() and is used to inject app instance into manifest. You don't have to do anything: app will be injected into every manifest you write, and inside manifest methods you may access it as $this->app . If you want to know, what useful methods you can leverage from app instance - please read dedicated Apps article. Manifest configuration ManifestInterface also extends ConfigAwareInterface , which declares single method setConfig() . As with setApp() , you don't call this method either - it is called by framework on every manifest. In manifest class you can use inherited property $this->config , which has array type. By default this property will contain an empty array. If you want to pass some configuration to manifest - use bundle configuration, which should be stored in file config/packages/dealroadshow_k8s.yaml in your Symfony project: dealroadshow_k8s.yaml dealroadshow_k8s : apps : - alias : YOUR_APP_NAME class : YOUR_APP_CLASS manifests : world : replicas : 8 foo : bar Manifests configs are stored under key manifests: in this config. Each key in manifests object is a short name of manifest you want to configure, and value for that key - is manifest configuration. So if you have WorldDeployment class with short name world and a configuration as above - property $config in your deployment will contain such array: $this->config === ['replicas' => 8, 'foo' => 'bar']; // true You than may use this configuration as follows: public function replicas(): int { return $this->config['replicas']; } Using bundle configuration file dealroadshow_k8s.yaml allows you to manage your environments easily, since you may create separate bundle configuration files for different envs - like config/packages/prod/dealroadshow_k8s.yaml for production and config/packages/dev/dealroadshow_k8s.yaml for development: a good example is option replicas above - you may want 8 replicas for your deployment in production, but you definetely want just 1 replica when you run your code locally on laptop. Configuration Environments is a default feature of Symfony Framework and you can read about this in official docs . But as good as this Symfony feature is, it is NOT considered as best practice for environments management in K8S framework. The main downside of using configuration values in your manifests is that your code is not very descriptive - for example, if you look at method replicas() above - you don't see how much replicas this development will actually have; you must navigate to configuration file for corresponding environment and look for this replicas value there. It would be nice if looking at class itself is all you need to imagine how resulting YAML manifest will look like. More on that in Environments Management . Manifest metadata You may have noticed that every Kubernetes manifest has keys kind and metadata . In fact, manifest name is defined under metadata key, and every manifest has name. That's why ManifestInterface also extends MetadataAwareInterface and thus needs method metadata() defined. Since names for manifests are generated automatically, it means that metadata key is always generated. Method metadata is defined in any abstract class that you will use, such as AbstractDeployment , AbstractIngress etc. But apart from manifest name, metadata should also contain the same labels, as selector section - this is needed for deployment to be able to \"find\" pods it manages. Luckily, you don't have to copy that labels from selector section to metadata section - just define selector() method, and framework will make sure that selector labels are copied to metadata section in a top level of manifest and to pod template metadata section for workloads (deployments, jobs etc.). Manifest class has flat structure For demonstration purposes, let's look at YAML manifest, generated from WorldDeployment class, defined in Getting Started article: hello/world.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 apiVersion: apps/v1 kind: Deployment metadata: labels: app: hello name: world name: hello-world spec: replicas: 1 selector: matchLabels: app: hello name: world template: metadata: annotations: dealroadshow.com/env-sources-checksum: d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum: d41d8cd98f00b204e9800998ecf8427e labels: app: hello name: world spec: containers: - image: nginx imagePullPolicy: IfNotPresent name: app ports: - { containerPort: 80, name: http } - { containerPort: 443, name: https } By looking at ports key in line 28 we see that this key is located deep down in YAML object structure: spec -> template -> spec -> containers[0] -> ports . Oddly enough, ports() is a method in WorldDeployment class - this method is not \"hidden\" somewhere deep down in class hierarchy. This is a one of the main conventions in K8S framework - classes flatten actual YAML structure where possible. That's why method ports() is a top-level citizen of deployment class. Defining container methods in workload classes Some of you may have noticed weird part in a previous section: ports is a part of container specification, and containers section in line 23 in our YAML file is actually an array. So how do we define ports() method in deployment class, if there can be many containers, thus many ports sections? The trick here is AbstractContainerDeployment class, which we extend in our WorldDeployment class. Any deployment class has containers() method, which should return a collection of ContainerInterface instances. AbstractContainerDeployment uses the fact that most of the multi-container workloads have one \"main\" container, which is an application itself and one or more \"auxiliary\" ones. For example, you may have deployment with 2 containers - php-fpm and nginx . You have your application in php-fpm container, therefore it's a \"main\" container here, and nginx container is just \"auxiliary\" one that helps you to expose your application via Web. You could create 2 classes, PhpFpmContainer and NginxContainer , and then return them in your method WorldDeployment::containers() like follows: WorldDeployment.php class WorldDeployment extends AbstractDeployment { public function containers(): iterable { yield new PhpFpmContainer(); yield new NginxContainer(); } //... } But having said that php-fpm is our main deployment and contains a big part of \"deployment purpose\" - it would be more descriptive to have this container logic in deployment class itself. That's why AbstractContainerDeployment implements both ContainerInterface and DeploymentInterface and it's containers() method looks like follows: AbstractContainerDeployment.php public function containers(): iterable { yield $this; } i.e. deployment returns itself as ContainerInterface and has methods both for deployment and container . Again, if we want to use php-fpm and nginx containers in our WorldDeployment class - we may extend it from AbstractContainerDeployment instead of AbstractDeployment , then define all methods for php-fpm container in our class, and then redeclare containers() method as follows: WorldDeployment.php public function containers(): iterable { yield $this; yield new NginxContainer(); } More on containers in Containers article. Manifest method names convention At this moment you most likely already noticed it, but most methods in manifest classes, except shortName() and some internal framework methods are using the same names as corresponding sections in standard Kubernetes YAML manifest. So, basically if you know what you want to define in YAML manifest, you will not have problems with defining it in manifest class. For example, if you want to define restartPolicy section - you don't have to remember where in YAML object hierarchy this setting is (thanks to flat structure of manifest classes), or how to define it in your deployment class - just overwrite method restartPolicy() in your class. Start typing method name and your IDE will help you with defining this method. There are some exceptions for this rule, but they are very rare. Most manifest methods are void This is a part of framework's design. The main idea behind this decision is this: there should be as little space for mistakes, as possible. Your IDE should generate your method along with it's parameters when you start typing method's name. Then you should be able to type something like $someArgument-> , and your IDE will tell you, what methods this argument has (what are you limited to). This way you are limited to \"valid\" options in terms of manifests syntax, and only some logic mistakes are possible. If method needs to return instance of some class - basically convention is that this class should have one or more static constructors. Just type [ClassName]:: and see if there are some. For example, if your IDE generated method restartPolicy() for you, you'll probably see it like follows: public function restartPolicy(): RestartPolicy|null { return parent::restartPolicy(); } See the RestartPolicy return type? Just start typing return RestartPolicy:: in a method body, and IDE should give you a hint. After you've chosen one of static constructors, your method will look something like this: public function restartPolicy(): RestartPolicy { return RestartPolicy::always(); } This simple conventions will ease your experience of writing manifests and will drastically decrease number of errors. Summary In this article we learned how to define manifests, some best practices for writing manifest classes and some conventions that K8S Framework has in order to make your life easier. You may also want to learn about Environments Management or dive deeper into Containers .","title":"Manifests"},{"location":"concepts/manifests/#manifests-explained","text":"","title":"Manifests explained"},{"location":"concepts/manifests/#prerequisites","text":"This article and any other articles in this docs assume that you use Dealroadshow K8S Bundle with a Symfony project and default Symfony configuration ( autowiring and autoconfiguration enabled).","title":"Prerequisites"},{"location":"concepts/manifests/#defining-manifests","text":"Defining manifest in Dealroadshow K8S Framework - means to define it's PHP class. Thanks to Symfony's autowiring and autoconfiguration, K8S framework then finds all manifest classes, processes them and dumps them to YAML files. But what classes are considered as manifests? Well, all classes, that implement ManifestInterface . Let's look at this interface: ManifestInterface.php interface ManifestInterface extends AppAwareInterface, ConfigAwareInterface, MetadataAwareInterface { public static function kind(): string; public static function shortName(): string; public function fileNameWithoutExtension(): string; } We can see three methods that this interface defines and thus every manifest must have: kind() , shortName() and fileNameWithoutExtension() . As you may have guessed, method kind() just returns good old Kubernetes kind - Deployment , Service , Secret , Ingress or any other kind that is understendable by Kubernetes itself. You will probably never define this method by yourself, since you will use abstract classes, defined by framework, such as AbstractDeployment or AbstractSecret - they all have this method defined. Method fileNameWithoutExtension() is internal and is used in order to generate filenames of dumped manifests. You don't have to define it either.","title":"Defining manifests"},{"location":"concepts/manifests/#manifest-names","text":"The only method you need to define in every manifest is shortName() . Method is called shortName() , not name() , because it should return part of name, \"relative\" to app. By default, full name of generated manifest will be formed as {app name}-{manifest shortName} , so for example if you have an app class HelloApp , which method HelloApp::name() returns hello , and manifest WorldDeployment , which method WorldDeployment::shortName() returns world , generated YAML file will have name hello/world.deployment.yaml and will contain deployment with name hello-world . Tip Don't worry if you don't like this naming convention. K8S framework is very flexible and allows to change this behavior. If you want to use your own naming convention for manifests - please read Change naming convention Good to know In fact, manifest names are prefixed not with app names, but with app aliases . Term \"app name\" above is a slight simplification, good enough for the most of users, since by default \"app alias\" will be equal to \"app name\".","title":"Manifest names"},{"location":"concepts/manifests/#using-app-object-inside-manifests","text":"Please look again at ManifestInterface above. You may note that this interface extends other interfaces, first of which is AppAwareInterface . This interface declares a single method - setApp() and is used to inject app instance into manifest. You don't have to do anything: app will be injected into every manifest you write, and inside manifest methods you may access it as $this->app . If you want to know, what useful methods you can leverage from app instance - please read dedicated Apps article.","title":"Using app object inside manifests"},{"location":"concepts/manifests/#manifest-configuration","text":"ManifestInterface also extends ConfigAwareInterface , which declares single method setConfig() . As with setApp() , you don't call this method either - it is called by framework on every manifest. In manifest class you can use inherited property $this->config , which has array type. By default this property will contain an empty array. If you want to pass some configuration to manifest - use bundle configuration, which should be stored in file config/packages/dealroadshow_k8s.yaml in your Symfony project: dealroadshow_k8s.yaml dealroadshow_k8s : apps : - alias : YOUR_APP_NAME class : YOUR_APP_CLASS manifests : world : replicas : 8 foo : bar Manifests configs are stored under key manifests: in this config. Each key in manifests object is a short name of manifest you want to configure, and value for that key - is manifest configuration. So if you have WorldDeployment class with short name world and a configuration as above - property $config in your deployment will contain such array: $this->config === ['replicas' => 8, 'foo' => 'bar']; // true You than may use this configuration as follows: public function replicas(): int { return $this->config['replicas']; } Using bundle configuration file dealroadshow_k8s.yaml allows you to manage your environments easily, since you may create separate bundle configuration files for different envs - like config/packages/prod/dealroadshow_k8s.yaml for production and config/packages/dev/dealroadshow_k8s.yaml for development: a good example is option replicas above - you may want 8 replicas for your deployment in production, but you definetely want just 1 replica when you run your code locally on laptop. Configuration Environments is a default feature of Symfony Framework and you can read about this in official docs . But as good as this Symfony feature is, it is NOT considered as best practice for environments management in K8S framework. The main downside of using configuration values in your manifests is that your code is not very descriptive - for example, if you look at method replicas() above - you don't see how much replicas this development will actually have; you must navigate to configuration file for corresponding environment and look for this replicas value there. It would be nice if looking at class itself is all you need to imagine how resulting YAML manifest will look like. More on that in Environments Management .","title":"Manifest configuration"},{"location":"concepts/manifests/#manifest-metadata","text":"You may have noticed that every Kubernetes manifest has keys kind and metadata . In fact, manifest name is defined under metadata key, and every manifest has name. That's why ManifestInterface also extends MetadataAwareInterface and thus needs method metadata() defined. Since names for manifests are generated automatically, it means that metadata key is always generated. Method metadata is defined in any abstract class that you will use, such as AbstractDeployment , AbstractIngress etc. But apart from manifest name, metadata should also contain the same labels, as selector section - this is needed for deployment to be able to \"find\" pods it manages. Luckily, you don't have to copy that labels from selector section to metadata section - just define selector() method, and framework will make sure that selector labels are copied to metadata section in a top level of manifest and to pod template metadata section for workloads (deployments, jobs etc.).","title":"Manifest metadata"},{"location":"concepts/manifests/#manifest-class-has-flat-structure","text":"For demonstration purposes, let's look at YAML manifest, generated from WorldDeployment class, defined in Getting Started article: hello/world.deployment.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 apiVersion: apps/v1 kind: Deployment metadata: labels: app: hello name: world name: hello-world spec: replicas: 1 selector: matchLabels: app: hello name: world template: metadata: annotations: dealroadshow.com/env-sources-checksum: d41d8cd98f00b204e9800998ecf8427e dealroadshow.com/volume-sources-checksum: d41d8cd98f00b204e9800998ecf8427e labels: app: hello name: world spec: containers: - image: nginx imagePullPolicy: IfNotPresent name: app ports: - { containerPort: 80, name: http } - { containerPort: 443, name: https } By looking at ports key in line 28 we see that this key is located deep down in YAML object structure: spec -> template -> spec -> containers[0] -> ports . Oddly enough, ports() is a method in WorldDeployment class - this method is not \"hidden\" somewhere deep down in class hierarchy. This is a one of the main conventions in K8S framework - classes flatten actual YAML structure where possible. That's why method ports() is a top-level citizen of deployment class.","title":"Manifest class has flat structure"},{"location":"concepts/manifests/#defining-container-methods-in-workload-classes","text":"Some of you may have noticed weird part in a previous section: ports is a part of container specification, and containers section in line 23 in our YAML file is actually an array. So how do we define ports() method in deployment class, if there can be many containers, thus many ports sections? The trick here is AbstractContainerDeployment class, which we extend in our WorldDeployment class. Any deployment class has containers() method, which should return a collection of ContainerInterface instances. AbstractContainerDeployment uses the fact that most of the multi-container workloads have one \"main\" container, which is an application itself and one or more \"auxiliary\" ones. For example, you may have deployment with 2 containers - php-fpm and nginx . You have your application in php-fpm container, therefore it's a \"main\" container here, and nginx container is just \"auxiliary\" one that helps you to expose your application via Web. You could create 2 classes, PhpFpmContainer and NginxContainer , and then return them in your method WorldDeployment::containers() like follows: WorldDeployment.php class WorldDeployment extends AbstractDeployment { public function containers(): iterable { yield new PhpFpmContainer(); yield new NginxContainer(); } //... } But having said that php-fpm is our main deployment and contains a big part of \"deployment purpose\" - it would be more descriptive to have this container logic in deployment class itself. That's why AbstractContainerDeployment implements both ContainerInterface and DeploymentInterface and it's containers() method looks like follows: AbstractContainerDeployment.php public function containers(): iterable { yield $this; } i.e. deployment returns itself as ContainerInterface and has methods both for deployment and container . Again, if we want to use php-fpm and nginx containers in our WorldDeployment class - we may extend it from AbstractContainerDeployment instead of AbstractDeployment , then define all methods for php-fpm container in our class, and then redeclare containers() method as follows: WorldDeployment.php public function containers(): iterable { yield $this; yield new NginxContainer(); } More on containers in Containers article.","title":"Defining container methods in workload classes"},{"location":"concepts/manifests/#manifest-method-names-convention","text":"At this moment you most likely already noticed it, but most methods in manifest classes, except shortName() and some internal framework methods are using the same names as corresponding sections in standard Kubernetes YAML manifest. So, basically if you know what you want to define in YAML manifest, you will not have problems with defining it in manifest class. For example, if you want to define restartPolicy section - you don't have to remember where in YAML object hierarchy this setting is (thanks to flat structure of manifest classes), or how to define it in your deployment class - just overwrite method restartPolicy() in your class. Start typing method name and your IDE will help you with defining this method. There are some exceptions for this rule, but they are very rare.","title":"Manifest method names convention"},{"location":"concepts/manifests/#most-manifest-methods-are-void","text":"This is a part of framework's design. The main idea behind this decision is this: there should be as little space for mistakes, as possible. Your IDE should generate your method along with it's parameters when you start typing method's name. Then you should be able to type something like $someArgument-> , and your IDE will tell you, what methods this argument has (what are you limited to). This way you are limited to \"valid\" options in terms of manifests syntax, and only some logic mistakes are possible. If method needs to return instance of some class - basically convention is that this class should have one or more static constructors. Just type [ClassName]:: and see if there are some. For example, if your IDE generated method restartPolicy() for you, you'll probably see it like follows: public function restartPolicy(): RestartPolicy|null { return parent::restartPolicy(); } See the RestartPolicy return type? Just start typing return RestartPolicy:: in a method body, and IDE should give you a hint. After you've chosen one of static constructors, your method will look something like this: public function restartPolicy(): RestartPolicy { return RestartPolicy::always(); } This simple conventions will ease your experience of writing manifests and will drastically decrease number of errors.","title":"Most manifest methods are void"},{"location":"concepts/manifests/#summary","text":"In this article we learned how to define manifests, some best practices for writing manifest classes and some conventions that K8S Framework has in order to make your life easier. You may also want to learn about Environments Management or dive deeper into Containers .","title":"Summary"},{"location":"howtos/change-naming-convention/","text":"","title":"Change naming convention"}]}